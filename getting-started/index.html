<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><link rel="canonical" href="http://die.mrmeeseeks.net/getting-started/" />
      <link rel="shortcut icon" href="../img/favicon.ico" />
    <title>Getting Started - MrMeeseeks.DIE</title>
    <link rel="stylesheet" href="../css/theme.css" />
    <link rel="stylesheet" href="../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/github.min.css" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "Getting Started";
        var mkdocs_page_input_path = "getting-started.md";
        var mkdocs_page_url = "/getting-started/";
      </script>
    
    <script src="../js/jquery-3.6.0.min.js" defer></script>
    <!--[if lt IE 9]>
      <script src="../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
      <script>hljs.initHighlightingOnLoad();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href=".." class="icon icon-home"> MrMeeseeks.DIE
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="..">Home</a>
                </li>
              </ul>
              <ul class="current">
                <li class="toctree-l1 current"><a class="reference internal current" href="./">Getting Started</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#our-first-container">Our First Container</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#making-it-dependency-injection-idiomatic">Making It Dependency Injection Idiomatic</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#generated-code">Generated Code</a>
    </li>
    </ul>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../configuration/">Configuration</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../naming-rules/">Naming Rules</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../scoping/">Scoping</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../user-defined-elements/">User-defined Elements</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../disposal/">Disposal</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../injections/">Injections</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../async-support/">Async Support</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../generics-support/">Generics Support</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../decorators-composites/">Decorators & Composites</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../initializers/">Initializers</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../glossary/">Glossary</a>
                </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="..">MrMeeseeks.DIE</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href=".." class="icon icon-home" alt="Docs"></a> &raquo;</li>
      <li>Getting Started</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="getting-started">Getting Started</h1>
<p>This tutorial-like section is intended for beginners and users who are completely new to DIE. It's just meant to get you started.</p>
<h2 id="our-first-container">Our First Container</h2>
<p>First, we need an implementation that can later be built by the container. We'll start with:</p>
<pre><code class="language-csharp">namespace GettingStarted;

internal class Logger
{
    public void Log(string message) =&gt; Console.WriteLine(message);
}
</code></pre>
<p>That's enough for a first small container configuration:</p>
<pre><code class="language-csharp">using MrMeeseeks.DIE.Configuration.Attributes;

namespace GettingStarted;

[ImplementationAggregation(typeof(Logger))]

[CreateFunction(typeof(Logger), &quot;Create&quot;)]
internal sealed partial class Container
{
    private Container() { }
}
</code></pre>
<p>Here we have our container. The <code>ImplementationAggregation</code> attribute registers our <code>Logger</code> class as an implementation to be considered by the container. The <code>CreateFunction</code> attribute instructs the container to create a <code>Logger Create()</code> function (i.e. a factory method that returns an instance of type Logger).</p>
<p>With DIE a container needs to have at least one explicit constructor and all constructors should be private. These are necessary constraints of DIE in order to guarantee intitialization features (which we won't use in this example, however).</p>
<p>We are ready to use it:</p>
<pre><code class="language-csharp">await using var container = GettingStarted.Container.DIE_CreateContainer();
var logger = container.Create();
logger.Log(&quot;Hello, World!&quot;);
</code></pre>
<p>This is it! Probably the simplest example you can think of, but it's a start ;)</p>
<p>The <code>await using</code> will asynchronously dispose of the container at the end. In this example it's not necessary because we don't have any disposables in use yet. However, this will prepare the use for future changes. But keep in mind that it's not forced upon you. If you don't need it you can remove it at your own risk of missing to dispose resources.</p>
<p>Please note that we don't use the container class constructor directly, but the a generated static function that creates a container instance via that constructor. If we would use the before mentioned initialization features, then they would be placed at this static function and therefore guaranteed to be processed as well.</p>
<h2 id="making-it-dependency-injection-idiomatic">Making It Dependency Injection Idiomatic</h2>
<p>Let's spice things up a bit. With dependency injection, in most cases it's better style to depend on interfaces (abstractions) rather than concrete classes (implementations). So what do we need to change? Let's start with the <code>Logger</code> class again:</p>
<pre><code class="language-csharp">namespace GettingStarted;

public interface ILogger
{
    void Log(string message);
}

internal class Logger : ILogger
{
    public void Log(string message) =&gt; Console.WriteLine(message);
}
</code></pre>
<p>And now a class that depends on it:</p>
<pre><code class="language-csharp">namespace GettingStarted;

internal interface IMrMeeseeks
{
    void Greet();
}

internal class MrMeeseeks : IMrMeeseeks
{
    private readonly ILogger _logger;

    internal MrMeeseeks(ILogger logger) =&gt; 
        _logger = logger;

    public void Greet() =&gt; 
        _logger.Log(&quot;I'm MrMeeseeks! Look at me!&quot;);
}
</code></pre>
<p>Some adjustments to the container, …</p>
<pre><code class="language-csharp">using MrMeeseeks.DIE.Configuration.Attributes;

namespace GettingStarted;

[ImplementationAggregation(
    typeof(Logger), 
    typeof(MrMeeseeks))]

[CreateFunction(typeof(MrMeeseeks), &quot;Create&quot;)]
internal sealed partial class Container
{

}
</code></pre>
<p>… and using it:</p>
<pre><code class="language-csharp">using var container = new GettingStarted.Container();
var mrMeeseeks = container.Create();
mrMeeseeks.Greet();
</code></pre>
<p>Now we are using abstractions and have a true dependency (i.e. <code>MrMeeseeks</code> depends on an instance of type <code>ILogger</code>).</p>
<p>Note that mapping interfaces to a specific implementation is only necessary if the interface has multiple configured implementations. If the interface has a single configured implementation, DIE will automatically choose it. With multiple implementations, a manual choice of the configured implementation is required, but that is a more advanced topic.</p>
<h2 id="generated-code">Generated Code</h2>
<p>Let's have a look at the generated code:</p>
<pre><code class="language-csharp">#nullable enable
namespace MrMeeseeks.DIE.Samples.GettingStarted
{
    sealed partial class Container : global::MrMeeseeks.DIE.Samples.GettingStarted.Container.ITransientScope_0_11, global::System.IAsyncDisposable, global::System.IDisposable
    {
        public static global::MrMeeseeks.DIE.Samples.GettingStarted.Container DIE_CreateContainer()
        {
            global::MrMeeseeks.DIE.Samples.GettingStarted.Container container_0_10 = new global::MrMeeseeks.DIE.Samples.GettingStarted.Container();
            return container_0_10;
        }

        internal global::MrMeeseeks.DIE.Samples.GettingStarted.MrMeeseeks Create()
        {
            if (Disposed_0_2)
                throw new System.ObjectDisposedException(&quot;global::MrMeeseeks.DIE.Samples.GettingStarted.Container&quot;, $&quot;[DIE] This scope \&quot;global::MrMeeseeks.DIE.Samples.GettingStarted.Container\&quot; is already disposed, so it can't create a \&quot;global::MrMeeseeks.DIE.Samples.GettingStarted.MrMeeseeks\&quot; instance anymore.&quot;);
            global::MrMeeseeks.DIE.Samples.GettingStarted.MrMeeseeks functionCallResult_2_1 = (global::MrMeeseeks.DIE.Samples.GettingStarted.MrMeeseeks)CreateMrMeeseeks_2_0();
            if (Disposed_0_2)
                throw new System.ObjectDisposedException(&quot;global::MrMeeseeks.DIE.Samples.GettingStarted.Container&quot;, $&quot;[DIE] This scope \&quot;global::MrMeeseeks.DIE.Samples.GettingStarted.Container\&quot; is already disposed, so it can't create a \&quot;global::MrMeeseeks.DIE.Samples.GettingStarted.MrMeeseeks\&quot; instance anymore.&quot;);
            return functionCallResult_2_1;
        }

        private global::MrMeeseeks.DIE.Samples.GettingStarted.MrMeeseeks CreateMrMeeseeks_2_0()
        {
            global::MrMeeseeks.DIE.Samples.GettingStarted.Logger logger_2_4 = new global::MrMeeseeks.DIE.Samples.GettingStarted.Logger();
            global::MrMeeseeks.DIE.Samples.GettingStarted.ILogger iLogger_2_3 = (global::MrMeeseeks.DIE.Samples.GettingStarted.ILogger)logger_2_4;
            global::MrMeeseeks.DIE.Samples.GettingStarted.MrMeeseeks mrMeeseeks_2_2 = new global::MrMeeseeks.DIE.Samples.GettingStarted.MrMeeseeks(logger: iLogger_2_3);
            return mrMeeseeks_2_2;
        }

        private global::System.Collections.Concurrent.ConcurrentBag&lt;global::System.IAsyncDisposable&gt; concurrentBag_0_7 = new global::System.Collections.Concurrent.ConcurrentBag&lt;global::System.IAsyncDisposable&gt;();
        private global::System.Collections.Concurrent.ConcurrentBag&lt;global::System.IDisposable&gt; concurrentBag_0_6 = new global::System.Collections.Concurrent.ConcurrentBag&lt;global::System.IDisposable&gt;();
        private int _disposed_0_0 = 0;
        private bool Disposed_0_2 =&gt; _disposed_0_0 != 0;
        public async global::System.Threading.Tasks.ValueTask DisposeAsync()
        {
            var disposed_0_1 = global::System.Threading.Interlocked.Exchange(ref _disposed_0_0, 1);
            if (disposed_0_1 != 0)
                return;
            global::System.Collections.Generic.List&lt;global::System.Exception&gt; aggregateException_0_4 = new global::System.Collections.Generic.List&lt;global::System.Exception&gt;();
            try
            {
                while (transientScopeDisposal_0_8.Count &gt; 0)
                {
                    var transientScopeToDispose_0_9 = System.Linq.Enumerable.FirstOrDefault(transientScopeDisposal_0_8.Keys);
                    if (transientScopeToDispose_0_9 is not null &amp;&amp; transientScopeDisposal_0_8.TryRemove(transientScopeToDispose_0_9, out _))
                    {
                        try
                        {
                            (transientScopeToDispose_0_9 as global::System.IDisposable)?.Dispose();
                        }
                        catch (global::System.Exception exceptionToAggregate_0_5)
                        {
                            // catch and aggregate so other disposals are triggered
                            aggregateException_0_4.Add(exceptionToAggregate_0_5);
                        }
                    }
                }

                transientScopeDisposal_0_8.Clear();
                while (concurrentBag_0_7.Count &gt; 0 &amp;&amp; concurrentBag_0_7.TryTake(out var iDisposable_0_3))
                {
                    try
                    {
                        await iDisposable_0_3.DisposeAsync();
                    }
                    catch (global::System.Exception exceptionToAggregate_0_5)
                    {
                        // catch and aggregate so other disposals are triggered
                        aggregateException_0_4.Add(exceptionToAggregate_0_5);
                    }
                }

                while (concurrentBag_0_6.Count &gt; 0 &amp;&amp; concurrentBag_0_6.TryTake(out var iDisposable_0_3))
                {
                    try
                    {
                        iDisposable_0_3.Dispose();
                    }
                    catch (global::System.Exception exceptionToAggregate_0_5)
                    {
                        // catch and aggregate so other disposals are triggered
                        aggregateException_0_4.Add(exceptionToAggregate_0_5);
                    }
                }
            }
            finally
            {
            }

            if (aggregateException_0_4.Count == 1)
                throw aggregateException_0_4[0];
            else if (aggregateException_0_4.Count &gt; 1)
                throw new System.AggregateException(aggregateException_0_4);
        }

        public void Dispose()
        {
            var disposed_0_1 = global::System.Threading.Interlocked.Exchange(ref _disposed_0_0, 1);
            if (disposed_0_1 != 0)
                return;
            global::System.Collections.Generic.List&lt;global::System.Exception&gt; aggregateException_0_4 = new global::System.Collections.Generic.List&lt;global::System.Exception&gt;();
            try
            {
                while (transientScopeDisposal_0_8.Count &gt; 0)
                {
                    var transientScopeToDispose_0_9 = System.Linq.Enumerable.FirstOrDefault(transientScopeDisposal_0_8.Keys);
                    if (transientScopeToDispose_0_9 is not null &amp;&amp; transientScopeDisposal_0_8.TryRemove(transientScopeToDispose_0_9, out _))
                    {
                        try
                        {
                            (transientScopeToDispose_0_9 as global::System.IDisposable)?.Dispose();
                        }
                        catch (global::System.Exception exceptionToAggregate_0_5)
                        {
                            // catch and aggregate so other disposals are triggered
                            aggregateException_0_4.Add(exceptionToAggregate_0_5);
                        }
                    }
                }

                transientScopeDisposal_0_8.Clear();
                while (concurrentBag_0_7.Count &gt; 0 &amp;&amp; concurrentBag_0_7.TryTake(out var iDisposable_0_3))
                {
                    try
                    {
                        (iDisposable_0_3 as global::System.IDisposable)?.Dispose();
                    }
                    catch (global::System.Exception exceptionToAggregate_0_5)
                    {
                        // catch and aggregate so other disposals are triggered
                        aggregateException_0_4.Add(exceptionToAggregate_0_5);
                    }
                }

                while (concurrentBag_0_6.Count &gt; 0 &amp;&amp; concurrentBag_0_6.TryTake(out var iDisposable_0_3))
                {
                    try
                    {
                        iDisposable_0_3.Dispose();
                    }
                    catch (global::System.Exception exceptionToAggregate_0_5)
                    {
                        // catch and aggregate so other disposals are triggered
                        aggregateException_0_4.Add(exceptionToAggregate_0_5);
                    }
                }
            }
            finally
            {
            }

            if (aggregateException_0_4.Count == 1)
                throw aggregateException_0_4[0];
            else if (aggregateException_0_4.Count &gt; 1)
                throw new System.AggregateException(aggregateException_0_4);
        }

        private global::System.Collections.Concurrent.ConcurrentDictionary&lt;global::System.IDisposable, global::System.IDisposable&gt; transientScopeDisposal_0_8 = new global::System.Collections.Concurrent.ConcurrentDictionary&lt;global::System.IDisposable, global::System.IDisposable&gt;();
        private interface ITransientScope_0_11
        {
        }
    }
}
#nullable disable
</code></pre>
<p>If you want to look at the generated code yourself, you should add the following to the <code>.csproj</code> that contains the container:</p>
<pre><code class="language-xml">&lt;EmitCompilerGeneratedFiles&gt;true&lt;/EmitCompilerGeneratedFiles&gt;
&lt;CompilerGeneratedFilesOutputPath&gt;$(BaseIntermediateOutputPath)\GeneratedFiles&lt;/CompilerGeneratedFilesOutputPath&gt;
</code></pre>
<p>Then a copy of the generated code is placed in <code>obj\GeneratedFiles\…</code>. It is highly recommended to take a look at the generated code if you are interested in learning how DIE works. </p>
<p>The generated code doesn't look like much for this small example. However, you have to keep in mind that this is boilerplate code, which can be tedious to write quickly. Instead, with DIE, there is very little configuration that needs to be written. And second, as your projects grow, it's going to become increasingly burdensome to maintain a pure DIE container yourself. A DIE container, on the other hand, can be configured to adapt almost seamlessly to your ongoing changes using convenience features.</p>
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="Footer Navigation">
        <a href=".." class="btn btn-neutral float-left" title="Home"><span class="icon icon-circle-arrow-left"></span> Previous</a>
        <a href="../configuration/" class="btn btn-neutral float-right" title="Configuration">Next <span class="icon icon-circle-arrow-right"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
      <span><a href=".." style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
      <span><a href="../configuration/" style="color: #fcfcfc">Next &raquo;</a></span>
    
  </span>
</div>
    <script>var base_url = '..';</script>
    <script src="../js/theme_extra.js" defer></script>
    <script src="../js/theme.js" defer></script>
      <script src="../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
