{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MrMeeseeks.DIE The DIE is a secret agency organized by a bunch of Mr. Meeseekses. Its goal is to gather the information necessary to resolve your dependencies. Therefore \u2026 The acronym DIE stands for D ependency I njection DI E . Let the secret agency DIE compile this information to build factory methods that create instances of types of your choice. Introduction MrMeeseeks.DIE (just DIE in this documentation) is a compile-time dependency injection container for .Net. As such, it generates factory methods that create the instances you need. Instead of relying on reflection, the generated code uses the good old new operator to create instances, just as you'd probably do yourself if you were creating a pure DI container. Nuget The easiest way to use DIE is to get it via nuget. Here is the package page: https://www.nuget.org/packages/MrMeeseeks.DIE/ Either search for MrMeeseeks.DIE in the nuget manager of the IDE of your choice. Or call the following PowerShell command: Install-Package MrMeeseeks.DIE Alternatively, you can use dotnet : dotnet add [your project] package MrMeeseeks.DIE Or manually add the package reference to the target .csproj : <PackageReference Include=\"MrMeeseeks.DIE\" Version=\"[preferrably the current version]\" /> Characteristics Of DIE Compile-Time Code Generation Incomplete configurations will most likely result in a failed build Unambiguousness Container doesn't resolve ambiguity through assumptions Configuration features to resolve ambiguities Convenience Default behaviors designed to reduce the amount of configuration required Optional marker interfaces can be used for configurations Mass configuration (e.g., register all implementations with a single configuration) Flexibility Allows opt-in configuration style Allows opt-out configuration style Feature richness Scoping Async support Generics support User-defined elements (factories, custom parameters, \u2026) Generated factories (Func<\u2026>, Lazy<\u2026>) Decorators & Composites Collection injections (IEnumerable<\u2026>, IAsyncEnumerable<\u2026>, IList<\u2026> and many more) Maximum transparency Only your configuration code needs to know about DIE The rest of your code base can remain oblivious Further Docs Getting Started Concepts And Configurations Configuration Naming rules Scoping User-defined Elements Disposal Resolution Precedence Usage Injections Async Support Generics support Decorators & Composites Initializers Samples Glossary Repositories And Licenses This project has separate repositories and licenses for the source code and for this documentation. Source Code The source code is hosted on github under the MIT license: https://github.com/Yeah69/MrMeeseeks.DIE Documenation The documentation is hosted on github under The Unlicense license: https://github.com/Yeah69/MrMeeseeks.DIE.Docs Acknowledgements See page .","title":"Home"},{"location":"#welcome-to-mrmeeseeksdie","text":"The DIE is a secret agency organized by a bunch of Mr. Meeseekses. Its goal is to gather the information necessary to resolve your dependencies. Therefore \u2026 The acronym DIE stands for D ependency I njection DI E . Let the secret agency DIE compile this information to build factory methods that create instances of types of your choice.","title":"Welcome to MrMeeseeks.DIE"},{"location":"#introduction","text":"MrMeeseeks.DIE (just DIE in this documentation) is a compile-time dependency injection container for .Net. As such, it generates factory methods that create the instances you need. Instead of relying on reflection, the generated code uses the good old new operator to create instances, just as you'd probably do yourself if you were creating a pure DI container.","title":"Introduction"},{"location":"#nuget","text":"The easiest way to use DIE is to get it via nuget. Here is the package page: https://www.nuget.org/packages/MrMeeseeks.DIE/ Either search for MrMeeseeks.DIE in the nuget manager of the IDE of your choice. Or call the following PowerShell command: Install-Package MrMeeseeks.DIE Alternatively, you can use dotnet : dotnet add [your project] package MrMeeseeks.DIE Or manually add the package reference to the target .csproj : <PackageReference Include=\"MrMeeseeks.DIE\" Version=\"[preferrably the current version]\" />","title":"Nuget"},{"location":"#characteristics-of-die","text":"Compile-Time Code Generation Incomplete configurations will most likely result in a failed build Unambiguousness Container doesn't resolve ambiguity through assumptions Configuration features to resolve ambiguities Convenience Default behaviors designed to reduce the amount of configuration required Optional marker interfaces can be used for configurations Mass configuration (e.g., register all implementations with a single configuration) Flexibility Allows opt-in configuration style Allows opt-out configuration style Feature richness Scoping Async support Generics support User-defined elements (factories, custom parameters, \u2026) Generated factories (Func<\u2026>, Lazy<\u2026>) Decorators & Composites Collection injections (IEnumerable<\u2026>, IAsyncEnumerable<\u2026>, IList<\u2026> and many more) Maximum transparency Only your configuration code needs to know about DIE The rest of your code base can remain oblivious","title":"Characteristics Of DIE"},{"location":"#further-docs","text":"Getting Started Concepts And Configurations Configuration Naming rules Scoping User-defined Elements Disposal Resolution Precedence Usage Injections Async Support Generics support Decorators & Composites Initializers Samples Glossary","title":"Further Docs"},{"location":"#repositories-and-licenses","text":"This project has separate repositories and licenses for the source code and for this documentation.","title":"Repositories And Licenses"},{"location":"#source-code","text":"The source code is hosted on github under the MIT license: https://github.com/Yeah69/MrMeeseeks.DIE","title":"Source Code"},{"location":"#documenation","text":"The documentation is hosted on github under The Unlicense license: https://github.com/Yeah69/MrMeeseeks.DIE.Docs","title":"Documenation"},{"location":"#acknowledgements","text":"See page .","title":"Acknowledgements"},{"location":"acknowledgements/","text":"Acknowledgements Dependency Injection containers now have a longer history in .Net. So it will come as no surprise that DIE has predecessors and sources of inspiration in the form of other DI container projects. This page is intended as an appreciation for those very projects (sorted alphabeticaly). This part will be very opinionated and reflects my personal experience. I have not tried very many DI container projects. So I can't say anything about many of them. One last thing before the acknowledgements. DI containers besides DIE certainly do exist, it makes no sense denying it. They surely can also be better suited for your use case, if so go for it. If you had a look at DIE and other container projects and decided for an alternative, I would like to hear about the drivers and motivations. Feel free to write about it in the discussions . Autofac Project page: Autofac Autofac is probably the most popular of all DI containers in the .Net world. It has accompanied me throughout my professional career. Due to its popularity, Autofac was usually convincing to the teams that I worked with, as it is the most familiar to most people. Autofac has earned this reputation. It is a rock-solid Reflection-based container. It has all the features you need. I will forever be grateful to the project for introducing me to Dependency Injection supported by containers. DryIoc Project page: DryIoc Compared to other projects, I think DryIoc stands out because it dares to go its own way. For example, the interpretation of func parameters as overrides for transitive injections is something I have only discovered in this project. Which is one thing that was adopted by DIE. DryIoc started as a reflection-based container. In the meantime, however, it also has possibilities to be used as a compile-time container, which is called DryIocZero. I can heartily recommend everyone to take a look at this project. StrongInject Project page: StrongInject As one of the first source generator-based DI containers, I learned a lot from StrongInject. It has very quickly reached a high level of maturity and you can see in all corners that there is someone at work who knows his stuff. In terms of features, StrongInject has already come a long way and can certainly keep up with many long-established Reflection-based containers, which is impressive.","title":"Acknowledgements"},{"location":"acknowledgements/#acknowledgements","text":"Dependency Injection containers now have a longer history in .Net. So it will come as no surprise that DIE has predecessors and sources of inspiration in the form of other DI container projects. This page is intended as an appreciation for those very projects (sorted alphabeticaly). This part will be very opinionated and reflects my personal experience. I have not tried very many DI container projects. So I can't say anything about many of them. One last thing before the acknowledgements. DI containers besides DIE certainly do exist, it makes no sense denying it. They surely can also be better suited for your use case, if so go for it. If you had a look at DIE and other container projects and decided for an alternative, I would like to hear about the drivers and motivations. Feel free to write about it in the discussions .","title":"Acknowledgements"},{"location":"acknowledgements/#autofac","text":"Project page: Autofac Autofac is probably the most popular of all DI containers in the .Net world. It has accompanied me throughout my professional career. Due to its popularity, Autofac was usually convincing to the teams that I worked with, as it is the most familiar to most people. Autofac has earned this reputation. It is a rock-solid Reflection-based container. It has all the features you need. I will forever be grateful to the project for introducing me to Dependency Injection supported by containers.","title":"Autofac"},{"location":"acknowledgements/#dryioc","text":"Project page: DryIoc Compared to other projects, I think DryIoc stands out because it dares to go its own way. For example, the interpretation of func parameters as overrides for transitive injections is something I have only discovered in this project. Which is one thing that was adopted by DIE. DryIoc started as a reflection-based container. In the meantime, however, it also has possibilities to be used as a compile-time container, which is called DryIocZero. I can heartily recommend everyone to take a look at this project.","title":"DryIoc"},{"location":"acknowledgements/#stronginject","text":"Project page: StrongInject As one of the first source generator-based DI containers, I learned a lot from StrongInject. It has very quickly reached a high level of maturity and you can see in all corners that there is someone at work who knows his stuff. In terms of features, StrongInject has already come a long way and can certainly keep up with many long-established Reflection-based containers, which is impressive.","title":"StrongInject"},{"location":"async-support/","text":"Async Support DIE supports asynchronous programming in three ways: Async initializer Async CreateFunction (Value)Task-wrapped dependencies Async disposal Async Initializer The initialization is always called by DIE right after the instance is created and before it is used anywhere else. If the initialization returns a ValueTask or a Task then the initialization is asynchronous. From DIE's point of view this also makes the instantiation asynchronous. With synchronous initialization, this would mean that the instance could not be injected as a dependency into another instance until the initialization method was executed to completion. With asynchronous initialization, however, it depends on whether the asynchronously initialized dependency is injected directly or wrapped into a ValueTask or a Task . We'll look at both ways next. One at a time. Async CreateFunction In a codebase where all the implementations used are purely synchronous instantiations, using a CreateFunction attribute on a type T will result in the creation of three functions: one that returns an instance of T synchronously, and two that would return the instance wrapped in a ValueTask<T> and a Task<T> respectively. In the synchronous codebase, the latter two are just calling the synchronous function and wrapping the result. Therefore, all three functions are functionally equivalent in terms of creating the instance. But what would change if we had asynchronous instantiation in the codebase? If the code base has any async dependencies that aren't wrapped at injection, then DIE will generate await statements before the dependency is injected. Consequently, the instantiation of the root instance can only be asynchronous, also because of the following two design decisions: DIE will never use breaking calls like .Result or .Wait() . Otherwise deadlocks could be caused by the generated code. DIE will never switch synchronization contexts using Task.Run(\u2026) or .ConfigureAwait(false) . This means that if you need your instance to be created on a specific thread - like the main thread for UI applications - you just need to call the CreateFunction from that thread. Both of these design choices also imply that there can be no synchronous CreateFunction if any non-wrapped async instantiation is required. So if you still need a synchronous CreateFunction, you would need to wrap the dependencies. We'll look at this next. (Value)Task -wrapped Dependencies Let's say you have an async initialized implementation called AsyncDependency , and it is a dependency of Instance . Instead of injecting the instance of AsyncDependency into the instance of Instance the usual way, by injecting it directly into the constructor: internal class Instance { internal Instance( AsyncDependency asyncDependency) { // \u2026 } } With DIE, you have a second alternative option by injecting it wrapped in a ValueTask<AsyncDependency> or a Task<AsyncDependency> : internal class Instance { internal Instance( ValueTask<AsyncDependency> asyncDependency) { // \u2026 } } This way, DIE wouldn't need to use an away statement and thus still keep the synchronous CreateFunction enabled. Of course, this is only true if the Instance instance doesn't need the AsyncDependency instance in its constructor or initialization, because that would mean unwrapping the AsyncDependency instance and giving the Instance instance asynchronous initialization itself. This means that wrapping dependencies works best for use cases where the dependencies aren't needed at instantiation, but later. Another use case is whenever you want to start constructing the dependent instances before the async initialization of the dependencies is done. Otherwise, without wrapping, the initialization of the dependency is waited for before the construction of the dependent instance starts. If the use cases aren't relevant to you, and you don't need a synchronous `CreateFunction' in the case of asynchronous initializations, you can just inject the dependencies directly as usual. Wrapping is just an alternative supported by DIE. Async Disposal DIE will always let the container implement IAsyncDisposable . So if you want to make sure the container is always properly disposed of, use the IAsyncDisposable interface for disposal. If the container needs to track a dependency that implements IAsyncDisposable , then the container's IDisposable will be discarded, because at that point it's no longer a valid option (without blocking calls). Remarks On Generated Code Whenever appropriate, DIE will prefer a ValueTask<T> as the return type for an async function. Exceptions are where an explicit Task<T> is expected. If necessary, DIE can and will switch from ValueTask<T> to Task<T> and vice versa. Note that forcing DIE to convert to Task<T> will cause more allocations on the heap which may have been avoided. Summary Use async initializers if you need to call asynchronous methods during instantiation. Wrap asynchronous dependencies in a ValueTask<T>' or a Task ' if you don't want the container to await async initialization before injection. Otherwise\u2026 The async dependencies will be awaited and therefore the sync CreateFunction will be discarded during code generation. DIE will never use blocking calls to make asynchronous instances synchronous DIE will never change the synchronization context in the generated code. Therefore, no use of Task.Run(\u2026) . Therefore, no use of await MethodAsync().ConfigureAwait(false) . DIE will prefer to generate code using ValueTask over Task .","title":"Async Support"},{"location":"async-support/#async-support","text":"DIE supports asynchronous programming in three ways: Async initializer Async CreateFunction (Value)Task-wrapped dependencies Async disposal","title":"Async Support"},{"location":"async-support/#async-initializer","text":"The initialization is always called by DIE right after the instance is created and before it is used anywhere else. If the initialization returns a ValueTask or a Task then the initialization is asynchronous. From DIE's point of view this also makes the instantiation asynchronous. With synchronous initialization, this would mean that the instance could not be injected as a dependency into another instance until the initialization method was executed to completion. With asynchronous initialization, however, it depends on whether the asynchronously initialized dependency is injected directly or wrapped into a ValueTask or a Task . We'll look at both ways next. One at a time.","title":"Async Initializer"},{"location":"async-support/#async-createfunction","text":"In a codebase where all the implementations used are purely synchronous instantiations, using a CreateFunction attribute on a type T will result in the creation of three functions: one that returns an instance of T synchronously, and two that would return the instance wrapped in a ValueTask<T> and a Task<T> respectively. In the synchronous codebase, the latter two are just calling the synchronous function and wrapping the result. Therefore, all three functions are functionally equivalent in terms of creating the instance. But what would change if we had asynchronous instantiation in the codebase? If the code base has any async dependencies that aren't wrapped at injection, then DIE will generate await statements before the dependency is injected. Consequently, the instantiation of the root instance can only be asynchronous, also because of the following two design decisions: DIE will never use breaking calls like .Result or .Wait() . Otherwise deadlocks could be caused by the generated code. DIE will never switch synchronization contexts using Task.Run(\u2026) or .ConfigureAwait(false) . This means that if you need your instance to be created on a specific thread - like the main thread for UI applications - you just need to call the CreateFunction from that thread. Both of these design choices also imply that there can be no synchronous CreateFunction if any non-wrapped async instantiation is required. So if you still need a synchronous CreateFunction, you would need to wrap the dependencies. We'll look at this next.","title":"Async CreateFunction"},{"location":"async-support/#valuetask-wrapped-dependencies","text":"Let's say you have an async initialized implementation called AsyncDependency , and it is a dependency of Instance . Instead of injecting the instance of AsyncDependency into the instance of Instance the usual way, by injecting it directly into the constructor: internal class Instance { internal Instance( AsyncDependency asyncDependency) { // \u2026 } } With DIE, you have a second alternative option by injecting it wrapped in a ValueTask<AsyncDependency> or a Task<AsyncDependency> : internal class Instance { internal Instance( ValueTask<AsyncDependency> asyncDependency) { // \u2026 } } This way, DIE wouldn't need to use an away statement and thus still keep the synchronous CreateFunction enabled. Of course, this is only true if the Instance instance doesn't need the AsyncDependency instance in its constructor or initialization, because that would mean unwrapping the AsyncDependency instance and giving the Instance instance asynchronous initialization itself. This means that wrapping dependencies works best for use cases where the dependencies aren't needed at instantiation, but later. Another use case is whenever you want to start constructing the dependent instances before the async initialization of the dependencies is done. Otherwise, without wrapping, the initialization of the dependency is waited for before the construction of the dependent instance starts. If the use cases aren't relevant to you, and you don't need a synchronous `CreateFunction' in the case of asynchronous initializations, you can just inject the dependencies directly as usual. Wrapping is just an alternative supported by DIE.","title":"(Value)Task-wrapped Dependencies"},{"location":"async-support/#async-disposal","text":"DIE will always let the container implement IAsyncDisposable . So if you want to make sure the container is always properly disposed of, use the IAsyncDisposable interface for disposal. If the container needs to track a dependency that implements IAsyncDisposable , then the container's IDisposable will be discarded, because at that point it's no longer a valid option (without blocking calls).","title":"Async Disposal"},{"location":"async-support/#remarks-on-generated-code","text":"Whenever appropriate, DIE will prefer a ValueTask<T> as the return type for an async function. Exceptions are where an explicit Task<T> is expected. If necessary, DIE can and will switch from ValueTask<T> to Task<T> and vice versa. Note that forcing DIE to convert to Task<T> will cause more allocations on the heap which may have been avoided.","title":"Remarks On Generated Code"},{"location":"async-support/#summary","text":"Use async initializers if you need to call asynchronous methods during instantiation. Wrap asynchronous dependencies in a ValueTask<T>' or a Task ' if you don't want the container to await async initialization before injection. Otherwise\u2026 The async dependencies will be awaited and therefore the sync CreateFunction will be discarded during code generation. DIE will never use blocking calls to make asynchronous instances synchronous DIE will never change the synchronization context in the generated code. Therefore, no use of Task.Run(\u2026) . Therefore, no use of await MethodAsync().ConfigureAwait(false) . DIE will prefer to generate code using ValueTask over Task .","title":"Summary"},{"location":"configuration/","text":"Configuration The following features have a high value for DIE: Unambiguousness Convenience This means that DIE tries to be as convenient as possible while still maintaining unambiguousness. Minimal Example Let's show this by going through the minimal example: internal interface IInterface {} internal class Class : IInterface {} [AllImplementationsAggregation] [CreateFunction(typeof(IInterface), \"Create\")] internal partial class Container {} The CreateFunctionAttribute will result in the creation of the following three functions: public IInterface Create() public Task<IInterface> CreateAsync() public ValueTask<IInterface> CreateValueAsync() Each of these will return an instance of type Class either synchronously or asynchronously. The AllImplementationsAggregation is the way to tell the container to consider all accessible implementations of the entire code base. This includes the referenced assemblies (which includes the .Net assemblies). For this example, it would be sufficient to just explicitly configure the single implementation. However, using AllImplementationsAggregation is a more versatile approach, as you can now simply add more implementations without having to change the configuration. Thus, this approach seems more appropriate for a minimalist example. It also shows the convenience-based approach that DIE takes. Another aspect that is convenient in this example is that you don't need to register the implementation Class to be used for the interface IInterface . - public ValueTask CreateValueAsync()`. Each of these will return an instance of type Class either synchronously or asynchronously. The AllImplementationsAggregation is the way to tell the container to consider all accessible implementations of the entire code base. This includes the referenced assemblies (which includes the .Net assemblies). For this example, it would be sufficient to just explicitly configure the single implementation. However, using AllImplementationsAggregation is a more versatile approach, as you can now simply add more implementations without having to change the configuration. Thus, this approach seems more appropriate for a minimalist example. It also shows the convenience-based approach that DIE takes. Another aspect that is convenient in this example is that you don't need to register the implementation Class' to be used for the interface IInterface'. That's because there is only one known implementation of Class for IInterface (and it has only one constructor - the implicit default one). From the container's point of view, there is only one possible way to resolve Interface , and therefore the container can decide on it's own without you telling it explicitly. However, if there were other implementations for the interface that the container knew about, it wouldn't compile. In this case, you would need to extend the configuration by telling the container which of the implementations for the interface to use. This way, unambiguousness is maintained. Use cases of configuration Unfortunately, even the best codebases cannot be modeled in such a way that the container can automatically resolve everything once they reach a certain level of content or complexity. There may be configuration required to take advantage of advanced features like decorators & composites, or to resolve ambiguities like multiple implementations of interfaces or multiple constructors of implementations. That is why DIE has configuration capabilities, so you should be able to teach the container your intentions. Characteristics-focused Configurations Typically, DI containers take an implementation-oriented approach to configurations. That is, they start with the implementation and then add characteristics (e.g., scoping, transitivity, and so on). DIE chooses a different path. DIE reverses the traditional configuration principle by focusing on characteristics. The configuration attributes represent characteristics and collect the implementations that should apply them. Abstraction Configurations You can also register abstractions (e.g. interfaces). In this case, however, the characteristics are not applied to the abstractions themselves, but to all registered implementations that implement or inherit from the abstraction. This way you can use marker interfaces and don't have to register each implementation to a characteristics individually. For example, the ContainerInstanceImplementationAggregation attribute has an alternative ContainerInstanceAbstractionAggregation attribute. Marker interfaces can only be used by your own code. Therefore, even if you decide to use marker interfaces, using \"implementation\" attributes to assign characteristics to external implementations (e.g., .Net types) may still be the only feasible way. Recommended Marker Interfaces And Their Configurations The marker interfaces: public interface IContainerInstance { } public interface ITransientScopeInstance { } public interface IScopeInstance { } public interface ITransientScopeRoot { } public interface IScopeRoot { } public interface ITransient { } public interface ISyncTransient { } public interface IAsyncTransient { } public interface IDecorator<T> { } public interface IComposite<T> { } public interface IInitializer { void Initialize(); } public interface ITaskInitializer { Task InitializeAsync(); } public interface IValueTaskInitializer { ValueTask InitializeAsync(); } The configurations of the marker interfaces: [assembly:ContainerInstanceAbstractionAggregation(typeof(IContainerInstance))] [assembly:TransientScopeInstanceAbstractionAggregation(typeof(ITransientScopeInstance))] [assembly:ScopeInstanceAbstractionAggregation(typeof(IScopeInstance))] [assembly:TransientScopeRootAbstractionAggregation(typeof(ITransientScopeRoot))] [assembly:ScopeRootAbstractionAggregation(typeof(IScopeRoot))] [assembly:TransientAbstractionAggregation(typeof(ITransient))] [assembly:SyncTransientAbstractionAggregation(typeof(ISyncTransient))] [assembly:AsyncTransientAbstractionAggregation(typeof(IAsyncTransient))] [assembly:DecoratorAbstractionAggregation(typeof(IDecorator<>))] [assembly:CompositeAbstractionAggregation(typeof(IComposite<>))] [assembly:Initializer(typeof(IInitializer), nameof(IInitializer.Initialize))] [assembly:Initializer(typeof(ITaskInitializer), nameof(ITaskInitializer.InitializeAsync))] [assembly:Initializer(typeof(IValueTaskInitializer), nameof(IValueTaskInitializer.InitializeAsync))] The location of the marker interfaces can be in a separate assembly and therefore doesn't need to know anything about DIE. Only the location of the configurations needs to reference the namespace of the marker interface and DIE. By using marker interfaces, container configuration becomes much simpler, and focuses more on specialized settings. However, with DIE, it's up to you whether you want to use a \"marker interface\" configuration style. Aggregating, Choosing, and Filtering Most of DIE's configuration features fall into one of the following categories: Aggregation, Selection, Filter. Aggregation The aggregation configurations gather all types of an associated characteristic. For example, the ContainerInstanceImplementationAggregation attribute gathers all implementation types which shall be instantiated once and shared throughout the container. Aggregation is about collecting knowledge. The container will make decisions based only on the aggregated knowledge. If a container is configured to know of only one implementation of an interface that actually has multiple implementations, the container would still behave as if that interface had only one implementation. Choice Choices are a kind of configuration that let's you resolve ambiguities. For example, when an implementation has multiple constructors. Choices can also be a more convenient alternative to filtering. Another example: if an interface has multiple implementations, you can aggregate all the implementations and choose one for the interface. This way it is possible to inject dependencies of the interface type and the interface type collection ( IReadOnlyList<IInterface> ) into the same container (or scope). Filter For each aggregation and choice configuration, there is a filter configuration that does the exact opposite (filters aggregated items or removes choices). It's important to note that filters are applied only at the \"the beginning\" of the configured scope. That is, you can only filter aggregations and choices set in the parent configuration level. Descriptions Of The Attributes Implementations Disposal Scoping Decorator/Composite Generics Miscellaneous Configuration Levels There are three levels of configuration: Assembly Container (Transient) Scope In the currently configured level, the configurations of the previous level are applied first, then the filter configurations, and then the aggregations and choices. If you don't need to write a DI container implementation yourself, and therefore don't need to have many containers in the test project, then the benefit of having an assembly-level configuration may not be obvious. Typically, a single container would be sufficient for a code base, and I would actually recommend having only one container. If not for sharing configurations between multiple containers, then why would you need an assembly level configuration? A simple example use case would be: you want to aggregate all implementations at the container level, but with a few exceptions that should be omitted. An easy way to accomplish this would be to aggregate all implementations at the assembly level and filter the exceptions at the container level. Another important aspect to note is that configurations of both transient and normal scopes inherit the configuration of the container they're in. This means that configuration-wise, transient scopes and normal scopes are peers.","title":"Configuration"},{"location":"configuration/#configuration","text":"The following features have a high value for DIE: Unambiguousness Convenience This means that DIE tries to be as convenient as possible while still maintaining unambiguousness.","title":"Configuration"},{"location":"configuration/#minimal-example","text":"Let's show this by going through the minimal example: internal interface IInterface {} internal class Class : IInterface {} [AllImplementationsAggregation] [CreateFunction(typeof(IInterface), \"Create\")] internal partial class Container {} The CreateFunctionAttribute will result in the creation of the following three functions: public IInterface Create() public Task<IInterface> CreateAsync() public ValueTask<IInterface> CreateValueAsync() Each of these will return an instance of type Class either synchronously or asynchronously. The AllImplementationsAggregation is the way to tell the container to consider all accessible implementations of the entire code base. This includes the referenced assemblies (which includes the .Net assemblies). For this example, it would be sufficient to just explicitly configure the single implementation. However, using AllImplementationsAggregation is a more versatile approach, as you can now simply add more implementations without having to change the configuration. Thus, this approach seems more appropriate for a minimalist example. It also shows the convenience-based approach that DIE takes. Another aspect that is convenient in this example is that you don't need to register the implementation Class to be used for the interface IInterface . - public ValueTask CreateValueAsync()`. Each of these will return an instance of type Class either synchronously or asynchronously. The AllImplementationsAggregation is the way to tell the container to consider all accessible implementations of the entire code base. This includes the referenced assemblies (which includes the .Net assemblies). For this example, it would be sufficient to just explicitly configure the single implementation. However, using AllImplementationsAggregation is a more versatile approach, as you can now simply add more implementations without having to change the configuration. Thus, this approach seems more appropriate for a minimalist example. It also shows the convenience-based approach that DIE takes. Another aspect that is convenient in this example is that you don't need to register the implementation Class' to be used for the interface IInterface'. That's because there is only one known implementation of Class for IInterface (and it has only one constructor - the implicit default one). From the container's point of view, there is only one possible way to resolve Interface , and therefore the container can decide on it's own without you telling it explicitly. However, if there were other implementations for the interface that the container knew about, it wouldn't compile. In this case, you would need to extend the configuration by telling the container which of the implementations for the interface to use. This way, unambiguousness is maintained.","title":"Minimal Example"},{"location":"configuration/#use-cases-of-configuration","text":"Unfortunately, even the best codebases cannot be modeled in such a way that the container can automatically resolve everything once they reach a certain level of content or complexity. There may be configuration required to take advantage of advanced features like decorators & composites, or to resolve ambiguities like multiple implementations of interfaces or multiple constructors of implementations. That is why DIE has configuration capabilities, so you should be able to teach the container your intentions.","title":"Use cases of configuration"},{"location":"configuration/#characteristics-focused-configurations","text":"Typically, DI containers take an implementation-oriented approach to configurations. That is, they start with the implementation and then add characteristics (e.g., scoping, transitivity, and so on). DIE chooses a different path. DIE reverses the traditional configuration principle by focusing on characteristics. The configuration attributes represent characteristics and collect the implementations that should apply them.","title":"Characteristics-focused Configurations"},{"location":"configuration/#abstraction-configurations","text":"You can also register abstractions (e.g. interfaces). In this case, however, the characteristics are not applied to the abstractions themselves, but to all registered implementations that implement or inherit from the abstraction. This way you can use marker interfaces and don't have to register each implementation to a characteristics individually. For example, the ContainerInstanceImplementationAggregation attribute has an alternative ContainerInstanceAbstractionAggregation attribute. Marker interfaces can only be used by your own code. Therefore, even if you decide to use marker interfaces, using \"implementation\" attributes to assign characteristics to external implementations (e.g., .Net types) may still be the only feasible way.","title":"Abstraction Configurations"},{"location":"configuration/#recommended-marker-interfaces-and-their-configurations","text":"The marker interfaces: public interface IContainerInstance { } public interface ITransientScopeInstance { } public interface IScopeInstance { } public interface ITransientScopeRoot { } public interface IScopeRoot { } public interface ITransient { } public interface ISyncTransient { } public interface IAsyncTransient { } public interface IDecorator<T> { } public interface IComposite<T> { } public interface IInitializer { void Initialize(); } public interface ITaskInitializer { Task InitializeAsync(); } public interface IValueTaskInitializer { ValueTask InitializeAsync(); } The configurations of the marker interfaces: [assembly:ContainerInstanceAbstractionAggregation(typeof(IContainerInstance))] [assembly:TransientScopeInstanceAbstractionAggregation(typeof(ITransientScopeInstance))] [assembly:ScopeInstanceAbstractionAggregation(typeof(IScopeInstance))] [assembly:TransientScopeRootAbstractionAggregation(typeof(ITransientScopeRoot))] [assembly:ScopeRootAbstractionAggregation(typeof(IScopeRoot))] [assembly:TransientAbstractionAggregation(typeof(ITransient))] [assembly:SyncTransientAbstractionAggregation(typeof(ISyncTransient))] [assembly:AsyncTransientAbstractionAggregation(typeof(IAsyncTransient))] [assembly:DecoratorAbstractionAggregation(typeof(IDecorator<>))] [assembly:CompositeAbstractionAggregation(typeof(IComposite<>))] [assembly:Initializer(typeof(IInitializer), nameof(IInitializer.Initialize))] [assembly:Initializer(typeof(ITaskInitializer), nameof(ITaskInitializer.InitializeAsync))] [assembly:Initializer(typeof(IValueTaskInitializer), nameof(IValueTaskInitializer.InitializeAsync))] The location of the marker interfaces can be in a separate assembly and therefore doesn't need to know anything about DIE. Only the location of the configurations needs to reference the namespace of the marker interface and DIE. By using marker interfaces, container configuration becomes much simpler, and focuses more on specialized settings. However, with DIE, it's up to you whether you want to use a \"marker interface\" configuration style.","title":"Recommended Marker Interfaces And Their Configurations"},{"location":"configuration/#aggregating-choosing-and-filtering","text":"Most of DIE's configuration features fall into one of the following categories: Aggregation, Selection, Filter.","title":"Aggregating, Choosing, and Filtering"},{"location":"configuration/#aggregation","text":"The aggregation configurations gather all types of an associated characteristic. For example, the ContainerInstanceImplementationAggregation attribute gathers all implementation types which shall be instantiated once and shared throughout the container. Aggregation is about collecting knowledge. The container will make decisions based only on the aggregated knowledge. If a container is configured to know of only one implementation of an interface that actually has multiple implementations, the container would still behave as if that interface had only one implementation.","title":"Aggregation"},{"location":"configuration/#choice","text":"Choices are a kind of configuration that let's you resolve ambiguities. For example, when an implementation has multiple constructors. Choices can also be a more convenient alternative to filtering. Another example: if an interface has multiple implementations, you can aggregate all the implementations and choose one for the interface. This way it is possible to inject dependencies of the interface type and the interface type collection ( IReadOnlyList<IInterface> ) into the same container (or scope).","title":"Choice"},{"location":"configuration/#filter","text":"For each aggregation and choice configuration, there is a filter configuration that does the exact opposite (filters aggregated items or removes choices). It's important to note that filters are applied only at the \"the beginning\" of the configured scope. That is, you can only filter aggregations and choices set in the parent configuration level.","title":"Filter"},{"location":"configuration/#descriptions-of-the-attributes","text":"Implementations Disposal Scoping Decorator/Composite Generics Miscellaneous","title":"Descriptions Of The Attributes"},{"location":"configuration/#configuration-levels","text":"There are three levels of configuration: Assembly Container (Transient) Scope In the currently configured level, the configurations of the previous level are applied first, then the filter configurations, and then the aggregations and choices. If you don't need to write a DI container implementation yourself, and therefore don't need to have many containers in the test project, then the benefit of having an assembly-level configuration may not be obvious. Typically, a single container would be sufficient for a code base, and I would actually recommend having only one container. If not for sharing configurations between multiple containers, then why would you need an assembly level configuration? A simple example use case would be: you want to aggregate all implementations at the container level, but with a few exceptions that should be omitted. An easy way to accomplish this would be to aggregate all implementations at the assembly level and filter the exceptions at the container level. Another important aspect to note is that configurations of both transient and normal scopes inherit the configuration of the container they're in. This means that configuration-wise, transient scopes and normal scopes are peers.","title":"Configuration Levels"},{"location":"decorators-composites/","text":"Decorators & Composites The purpose of both decorators & composites is to transparently add functionality to an instance of an interface. They do this by wrapping one or more instances of that interface and implementing the interface themselves. The main difference is that while a decorator wraps a single instance, a composite wraps a collection of instances. Therefore, the decorator is used to extend functionality to a decorated instance, and the composite is used to aggregate over multiple instances. The book \"Design Patterns\" by the Gang of Four is recommended for a better and more thorough description of these two patterns. Why Is The Container Responsible For Decorators & Composites? Because decorators and composites implement the same interface they're wrapping, they become transparent as soon as they're injected as that interface. The consuming side that gets an instance of such an interface injected is completely unaware of it. The consumer neither knows nor makes any assumptions about whether the injected instance is the implementation, or whether there is a chain of decorators in between, or whether it is a composition of implementations. And that is exactly what we are doing with dependency injection: externalizing such responsibilities (decorating & composing interfaces). When using a container, the external entity that manages decorators and composites can only be the container, because it is the entity that injects the dependencies. This is why DIE supports the use of decorators & composites. Special Kind Of Implementation Decorators & Composites are considered implementations in DIE and must be registered/aggregated as such. However, they are a special type of implementation. They won't be used as standalone implementations, but always only in addition to \"pure\" implementations. Decorators Example internal interface IInterface { IInterface Decorated { get; } } internal class Dependency : IInterface { public IInterface Decorated => this; } internal class Decorator : IInterface, IDecorator<IInterface> { public Decorator(IInterface decoratedNormal) => Decorated = decoratedNormal; public IInterface Decorated { get; } } Requirements Implement the interface you want to decorate (e.g., IInterface ) Implement the marker decorator interface (e.g. IDecorator<> ), which will be registered with a DecoratorAbstractionAggregation attribute. The decorator interface should have its generic parameter set to the decorated interface: IDecorator<IInterface> . Should have a constructor parameter of the type of the decorated interface Some Remarks If a decorated interface has multiple decorators registered, you must configure the order in which the decorators are applied, since DIE can't assume any by itself. You can configure an individual decorator sequence per decorated type and/or a fallback sequence configuration for the decorated interface. If you configure an empty sequence, you're effectively disabling decoration. If a decorated interface has only one decorator, then a sequence decoration isn't necessary. DIE assumes the intent of decorator usage by its existence, and there's no ambiguity about which decorator to apply first. Decorators are never scoped instances, even if the decorated instance is scoped. Composites Example internal interface IInterface { IReadOnlyList<IInterface> Composites { get; } } internal class BasisA : IInterface { public IReadOnlyList<IInterface> Composites => new List<IInterface> { this }; } internal class BasisB : IInterface { public IReadOnlyList<IInterface> Composites => new List<IInterface> { this }; } internal class Composite : IInterface, IComposite<IInterface> { public Composite(IReadOnlyList<IInterface> composites) => Composites = composites; public IReadOnlyList<IInterface> Composites { get; } } Requirements Implement the interface that will be composited (e.g., IInterface ) Implement the marker composite interface (e.g. IComposite<> ), which will be registered with a CompositeAbstractionAggregation attribute. The composite interface should have its generic parameter set to the composited interface: IComposite<IInterface> . Should have a constructor parameter of the collection type of the composite interface Some Remarks Composites are never scoped instances, even if all of the composite instances are scoped. You can have only one composite type per interface. Combinations If the interface has multiple implementations and is both decorated and composited, then you can combine decorators and composites however you like. You can even decorate the composite.","title":"Decorators & Composites"},{"location":"decorators-composites/#decorators-composites","text":"The purpose of both decorators & composites is to transparently add functionality to an instance of an interface. They do this by wrapping one or more instances of that interface and implementing the interface themselves. The main difference is that while a decorator wraps a single instance, a composite wraps a collection of instances. Therefore, the decorator is used to extend functionality to a decorated instance, and the composite is used to aggregate over multiple instances. The book \"Design Patterns\" by the Gang of Four is recommended for a better and more thorough description of these two patterns.","title":"Decorators &amp; Composites"},{"location":"decorators-composites/#why-is-the-container-responsible-for-decorators-composites","text":"Because decorators and composites implement the same interface they're wrapping, they become transparent as soon as they're injected as that interface. The consuming side that gets an instance of such an interface injected is completely unaware of it. The consumer neither knows nor makes any assumptions about whether the injected instance is the implementation, or whether there is a chain of decorators in between, or whether it is a composition of implementations. And that is exactly what we are doing with dependency injection: externalizing such responsibilities (decorating & composing interfaces). When using a container, the external entity that manages decorators and composites can only be the container, because it is the entity that injects the dependencies. This is why DIE supports the use of decorators & composites.","title":"Why Is The Container Responsible For Decorators &amp; Composites?"},{"location":"decorators-composites/#special-kind-of-implementation","text":"Decorators & Composites are considered implementations in DIE and must be registered/aggregated as such. However, they are a special type of implementation. They won't be used as standalone implementations, but always only in addition to \"pure\" implementations.","title":"Special Kind Of Implementation"},{"location":"decorators-composites/#decorators","text":"","title":"Decorators"},{"location":"decorators-composites/#example","text":"internal interface IInterface { IInterface Decorated { get; } } internal class Dependency : IInterface { public IInterface Decorated => this; } internal class Decorator : IInterface, IDecorator<IInterface> { public Decorator(IInterface decoratedNormal) => Decorated = decoratedNormal; public IInterface Decorated { get; } }","title":"Example"},{"location":"decorators-composites/#requirements","text":"Implement the interface you want to decorate (e.g., IInterface ) Implement the marker decorator interface (e.g. IDecorator<> ), which will be registered with a DecoratorAbstractionAggregation attribute. The decorator interface should have its generic parameter set to the decorated interface: IDecorator<IInterface> . Should have a constructor parameter of the type of the decorated interface","title":"Requirements"},{"location":"decorators-composites/#some-remarks","text":"If a decorated interface has multiple decorators registered, you must configure the order in which the decorators are applied, since DIE can't assume any by itself. You can configure an individual decorator sequence per decorated type and/or a fallback sequence configuration for the decorated interface. If you configure an empty sequence, you're effectively disabling decoration. If a decorated interface has only one decorator, then a sequence decoration isn't necessary. DIE assumes the intent of decorator usage by its existence, and there's no ambiguity about which decorator to apply first. Decorators are never scoped instances, even if the decorated instance is scoped.","title":"Some Remarks"},{"location":"decorators-composites/#composites","text":"","title":"Composites"},{"location":"decorators-composites/#example_1","text":"internal interface IInterface { IReadOnlyList<IInterface> Composites { get; } } internal class BasisA : IInterface { public IReadOnlyList<IInterface> Composites => new List<IInterface> { this }; } internal class BasisB : IInterface { public IReadOnlyList<IInterface> Composites => new List<IInterface> { this }; } internal class Composite : IInterface, IComposite<IInterface> { public Composite(IReadOnlyList<IInterface> composites) => Composites = composites; public IReadOnlyList<IInterface> Composites { get; } }","title":"Example"},{"location":"decorators-composites/#requirements_1","text":"Implement the interface that will be composited (e.g., IInterface ) Implement the marker composite interface (e.g. IComposite<> ), which will be registered with a CompositeAbstractionAggregation attribute. The composite interface should have its generic parameter set to the composited interface: IComposite<IInterface> . Should have a constructor parameter of the collection type of the composite interface","title":"Requirements"},{"location":"decorators-composites/#some-remarks_1","text":"Composites are never scoped instances, even if all of the composite instances are scoped. You can have only one composite type per interface.","title":"Some Remarks"},{"location":"decorators-composites/#combinations","text":"If the interface has multiple implementations and is both decorated and composited, then you can combine decorators and composites however you like. You can even decorate the composite.","title":"Combinations"},{"location":"disposal/","text":"Disposal Disposal is an integral part of containers in DIE. By default, disposables (either IDisposable or IAsyncDisposable implementations) are managed by the container or scope in which they are instantiated. Managing means that the disposables are cached until the scope or container is disposed of, and then disposed of as well. Marking a disposable implementation as transient relieves the container of the responsibility of managing the disposable. There are three options: Sync-transient (discard management for IDisposable ) Async-transient (discard management for IAsyncDisposable ) Transient (discard management for both, IDisposable & IAsyncDisposable ) That is, if an implementation implements both disposal interfaces, then when the container is disposed of \u2026 Both disposal methods will be called if it's not marked as transient in any way. Only the sync disposal method will be called if it is marked async-transient. Only the async method will be called if it is marked as sync-transient. None of the disposal methods will be called if marked transient. In addition, there is an option to manually add disposables to disposal management using certain user-defined elements ( DIE_AddForDisposal or DIE_AddForDisposalAsync ). DIE will automatically generate the disposal methods on the container and scope classes, so the user isn't allowed to implement them. If managed async disposables exist, only the IAsyncDisposable interface will be implemented (this prevents blocking disposal calls in the generated code). Otherwise, both disposal interfaces are implemented. When disposing of the container, it is sufficient to call one of the disposal methods if both are present. Once you call one of the disposal methods, the container is locked against further instantiation. This means that subsequent calls to create functions or factories that have been injected will cause an exception to be thrown. Scope's Disposal Behavior In many ways, the disposal behavior of scopes is the same as that of containers. They implement the disposal interfaces, they manage disposables, you can manage disposal by marking implementations as transient, and you can use the user-defined elements to manually attach disposables. However, disposing of the scopes themselves is handled differently. Even the normal scope and the transient scope have different behaviors. The normal scope isn't intended to be manually disposed of, and is itself attached to the parent scope (the one it was created from) for disposal. The transient scope isn't attached to its parent scope. Instead, it's scope root implementation can get an IDisposable or IAsyncDisposable dependency injected which can be used to eagerly & manually dispose of the transient scope prior to container disposal. However, transient scopes will still be attached to the containers disposal. Therefore, transient scopes can be used to eagerly dispose, but rest assured that they will be disposed at the latest when the container is disposed. Note: If async disposables are managed, then IDisposable injections won't work in transient scope root implementations. It'll cause a compile time error. Therefore it is always safer and recommended to use an IAsyncDisposable injection instead, which should always work.","title":"Disposal"},{"location":"disposal/#disposal","text":"Disposal is an integral part of containers in DIE. By default, disposables (either IDisposable or IAsyncDisposable implementations) are managed by the container or scope in which they are instantiated. Managing means that the disposables are cached until the scope or container is disposed of, and then disposed of as well. Marking a disposable implementation as transient relieves the container of the responsibility of managing the disposable. There are three options: Sync-transient (discard management for IDisposable ) Async-transient (discard management for IAsyncDisposable ) Transient (discard management for both, IDisposable & IAsyncDisposable ) That is, if an implementation implements both disposal interfaces, then when the container is disposed of \u2026 Both disposal methods will be called if it's not marked as transient in any way. Only the sync disposal method will be called if it is marked async-transient. Only the async method will be called if it is marked as sync-transient. None of the disposal methods will be called if marked transient. In addition, there is an option to manually add disposables to disposal management using certain user-defined elements ( DIE_AddForDisposal or DIE_AddForDisposalAsync ). DIE will automatically generate the disposal methods on the container and scope classes, so the user isn't allowed to implement them. If managed async disposables exist, only the IAsyncDisposable interface will be implemented (this prevents blocking disposal calls in the generated code). Otherwise, both disposal interfaces are implemented. When disposing of the container, it is sufficient to call one of the disposal methods if both are present. Once you call one of the disposal methods, the container is locked against further instantiation. This means that subsequent calls to create functions or factories that have been injected will cause an exception to be thrown.","title":"Disposal"},{"location":"disposal/#scopes-disposal-behavior","text":"In many ways, the disposal behavior of scopes is the same as that of containers. They implement the disposal interfaces, they manage disposables, you can manage disposal by marking implementations as transient, and you can use the user-defined elements to manually attach disposables. However, disposing of the scopes themselves is handled differently. Even the normal scope and the transient scope have different behaviors. The normal scope isn't intended to be manually disposed of, and is itself attached to the parent scope (the one it was created from) for disposal. The transient scope isn't attached to its parent scope. Instead, it's scope root implementation can get an IDisposable or IAsyncDisposable dependency injected which can be used to eagerly & manually dispose of the transient scope prior to container disposal. However, transient scopes will still be attached to the containers disposal. Therefore, transient scopes can be used to eagerly dispose, but rest assured that they will be disposed at the latest when the container is disposed. Note: If async disposables are managed, then IDisposable injections won't work in transient scope root implementations. It'll cause a compile time error. Therefore it is always safer and recommended to use an IAsyncDisposable injection instead, which should always work.","title":"Scope's Disposal Behavior"},{"location":"generics-support/","text":"Generics Support DIE supports the use of generic types. This includes both configuration and usage. Configuration Generic implementations can be configured to do the same things as non-generic implementations. However, generic implementations must be passed as unbound types. This means that instead of passing a concrete generic type parameter, it is left empty. Configurations for this unbound generic type then apply to all of its bound generic type variants. For example: [ContainerInstanceImplementationAggregation( typeof(DependencyA<>), typeof(DependencyB<,>))] This will configure all variants of the generic implementation DependencyA<\u2026> (e.g. DependencyA<int> or DependencyA<string> ) to be a container instance. The same logic applies to DependencyB<\u2026,\u2026> , which has two generic parameters. Usage Fortunately, C# doesn't allow the use of unbound generic types except in the typeof operator. This makes the use of implementation instance injections straightforward: internal class Dependency<T0> { } internal class DependencyHolder { internal DependencyHolder(Dependency<int> dependency) { } } Generic interface instance injections become more interesting. Straightforward usage is only possible for cases where each of the implementation types' generic parameters can be determined based on the interface type. For example: public interface IInterface<T0, T1> { } internal class Dependency<T0, T1> : IInterface<T1, T0> { } internal class DependencyHolder { internal DependencyHolder(IInterface<int, string> dependency) { } // A Dependency<string, int> instance } Cases with unspecified generic type parameters are supported by DIE. However, more specialized configuration would be required, as described in the next section \u2026 Unspecified Generic Type Parameters With Interface Injections There are situations where DIE can't automatically determine a generic type parameter for an implementation when injecting through an interface. Here is a minimal example: public interface IInterface<T> { } internal class Dependency<T0, T1> : IInterface<T1> { } internal class DependencyHolder { internal DependencyHolder(IInterface<int> dependency) { } // What should be put into T0? } So, in this example, if DIE needs to resolve DependencyHolder and Dependency<T0, T1> is the only implementation of Interface<T> , then it is clear that T1 will be assigned int . However, in this situation T0 can't be resolved. To resolve such situations, DIE provides a configuration feature. You can make a generic type parameter choice for instance injections (singular) or a generic type parameter collection choice for collection injections. Both are configured by implementation type. You can also mix these into types of choices. If you make only a singular choice, then it's also selected as a singular choice for collection injections. If you configure a single type in the collection choice, and don't configure a single choice, then it will be selected for instance injections. To resolve the example, the following configuration example can be applied: [GenericParameterChoice(typeof(Dependency<,>), \"T0\", typeof(string))] If you want to add type substitution for collection injection, you can use the following configuration: [GenericParameterSubstitutesChoice(typeof(Dependency<,>), \"T0\", typeof(int), typeof(byte))] With these two configurations in place, an IReadOnlyList<IInterface<int>> collection injection will contain a Dependency<string, int> , a Dependency<int, int> , and a Dependency<byte, int> instance. Let's consider another example: public interface IInterface { } internal class Dependency<T0, T1> : IInterface { } internal class DependencyHolder { internal DependencyHolder(IReadOnlyList<IInterface> dependencies) { } } And the following configuration accordingly: [GenericParameterSubstitutesChoice(typeof(Dependency<,>), \"T0\", typeof(int), typeof(byte))] [GenericParameterSubstitutesChoice(typeof(Dependency<,>), \"T1\", typeof(string), typeof(long))] In this example, DependencyHolder gets a collection injection with one instance of each of the types Dependency<int, string> , Dependency<int, long> , Dependency<byte, string> , and Dependency<byte, long> . This instantiates every possible combination of configured and open generic parameters. If the collection choices are used excessively, the numbers can quickly become large. Consider a class Dependency<T0, T1, T2, T3> that implements IInterface with each generic parameter configured with five types. A collection injection would contain 5 * 5 * 5 * 5 = 625 instances. Note that this will imply code generation for all of them and(!) their own dependencies.","title":"Generics Support"},{"location":"generics-support/#generics-support","text":"DIE supports the use of generic types. This includes both configuration and usage.","title":"Generics Support"},{"location":"generics-support/#configuration","text":"Generic implementations can be configured to do the same things as non-generic implementations. However, generic implementations must be passed as unbound types. This means that instead of passing a concrete generic type parameter, it is left empty. Configurations for this unbound generic type then apply to all of its bound generic type variants. For example: [ContainerInstanceImplementationAggregation( typeof(DependencyA<>), typeof(DependencyB<,>))] This will configure all variants of the generic implementation DependencyA<\u2026> (e.g. DependencyA<int> or DependencyA<string> ) to be a container instance. The same logic applies to DependencyB<\u2026,\u2026> , which has two generic parameters.","title":"Configuration"},{"location":"generics-support/#usage","text":"Fortunately, C# doesn't allow the use of unbound generic types except in the typeof operator. This makes the use of implementation instance injections straightforward: internal class Dependency<T0> { } internal class DependencyHolder { internal DependencyHolder(Dependency<int> dependency) { } } Generic interface instance injections become more interesting. Straightforward usage is only possible for cases where each of the implementation types' generic parameters can be determined based on the interface type. For example: public interface IInterface<T0, T1> { } internal class Dependency<T0, T1> : IInterface<T1, T0> { } internal class DependencyHolder { internal DependencyHolder(IInterface<int, string> dependency) { } // A Dependency<string, int> instance } Cases with unspecified generic type parameters are supported by DIE. However, more specialized configuration would be required, as described in the next section \u2026","title":"Usage"},{"location":"generics-support/#unspecified-generic-type-parameters-with-interface-injections","text":"There are situations where DIE can't automatically determine a generic type parameter for an implementation when injecting through an interface. Here is a minimal example: public interface IInterface<T> { } internal class Dependency<T0, T1> : IInterface<T1> { } internal class DependencyHolder { internal DependencyHolder(IInterface<int> dependency) { } // What should be put into T0? } So, in this example, if DIE needs to resolve DependencyHolder and Dependency<T0, T1> is the only implementation of Interface<T> , then it is clear that T1 will be assigned int . However, in this situation T0 can't be resolved. To resolve such situations, DIE provides a configuration feature. You can make a generic type parameter choice for instance injections (singular) or a generic type parameter collection choice for collection injections. Both are configured by implementation type. You can also mix these into types of choices. If you make only a singular choice, then it's also selected as a singular choice for collection injections. If you configure a single type in the collection choice, and don't configure a single choice, then it will be selected for instance injections. To resolve the example, the following configuration example can be applied: [GenericParameterChoice(typeof(Dependency<,>), \"T0\", typeof(string))] If you want to add type substitution for collection injection, you can use the following configuration: [GenericParameterSubstitutesChoice(typeof(Dependency<,>), \"T0\", typeof(int), typeof(byte))] With these two configurations in place, an IReadOnlyList<IInterface<int>> collection injection will contain a Dependency<string, int> , a Dependency<int, int> , and a Dependency<byte, int> instance. Let's consider another example: public interface IInterface { } internal class Dependency<T0, T1> : IInterface { } internal class DependencyHolder { internal DependencyHolder(IReadOnlyList<IInterface> dependencies) { } } And the following configuration accordingly: [GenericParameterSubstitutesChoice(typeof(Dependency<,>), \"T0\", typeof(int), typeof(byte))] [GenericParameterSubstitutesChoice(typeof(Dependency<,>), \"T1\", typeof(string), typeof(long))] In this example, DependencyHolder gets a collection injection with one instance of each of the types Dependency<int, string> , Dependency<int, long> , Dependency<byte, string> , and Dependency<byte, long> . This instantiates every possible combination of configured and open generic parameters. If the collection choices are used excessively, the numbers can quickly become large. Consider a class Dependency<T0, T1, T2, T3> that implements IInterface with each generic parameter configured with five types. A collection injection would contain 5 * 5 * 5 * 5 = 625 instances. Note that this will imply code generation for all of them and(!) their own dependencies.","title":"Unspecified Generic Type Parameters With Interface Injections"},{"location":"getting-started/","text":"Getting Started This tutorial-like section is intended for beginners and users who are completely new to DIE. It's just meant to get you started. Our First Container First, we need an implementation that can later be built by the container. We'll start with: namespace GettingStarted; internal class Logger { public void Log(string message) => Console.WriteLine(message); } That's enough for a first small container configuration: using MrMeeseeks.DIE.Configuration.Attributes; namespace GettingStarted; [ImplementationAggregation(typeof(Logger))] [CreateFunction(typeof(Logger), \"Create\")] internal sealed partial class Container { private Container() { } } Here we have our container. The ImplementationAggregation attribute registers our Logger class as an implementation to be considered by the container. The CreateFunction attribute instructs the container to create a Logger Create() function (i.e. a factory method that returns an instance of type Logger). With DIE a container needs to have at least one explicit constructor and all constructors should be private. These are necessary constraints of DIE in order to guarantee intitialization features (which we won't use in this example, however). We are ready to use it: await using var container = GettingStarted.Container.DIE_CreateContainer(); var logger = container.Create(); logger.Log(\"Hello, World!\"); This is it! Probably the simplest example you can think of, but it's a start ;) The await using will asynchronously dispose of the container at the end. In this example it's not necessary because we don't have any disposables in use yet. However, this will prepare the use for future changes. But keep in mind that it's not forced upon you. If you don't need it you can remove it at your own risk of missing to dispose resources. Please note that we don't use the container class constructor directly, but the a generated static function that creates a container instance via that constructor. If we would use the before mentioned initialization features, then they would be placed at this static function and therefore guaranteed to be processed as well. Making It Dependency Injection Idiomatic Let's spice things up a bit. With dependency injection, in most cases it's better style to depend on interfaces (abstractions) rather than concrete classes (implementations). So what do we need to change? Let's start with the Logger class again: namespace GettingStarted; public interface ILogger { void Log(string message); } internal class Logger : ILogger { public void Log(string message) => Console.WriteLine(message); } And now a class that depends on it: namespace GettingStarted; internal interface IMrMeeseeks { void Greet(); } internal class MrMeeseeks : IMrMeeseeks { private readonly ILogger _logger; internal MrMeeseeks(ILogger logger) => _logger = logger; public void Greet() => _logger.Log(\"I'm MrMeeseeks! Look at me!\"); } Some adjustments to the container, \u2026 using MrMeeseeks.DIE.Configuration.Attributes; namespace GettingStarted; [ImplementationAggregation( typeof(Logger), typeof(MrMeeseeks))] [CreateFunction(typeof(MrMeeseeks), \"Create\")] internal sealed partial class Container { } \u2026 and using it: using var container = new GettingStarted.Container(); var mrMeeseeks = container.Create(); mrMeeseeks.Greet(); Now we are using abstractions and have a true dependency (i.e. MrMeeseeks depends on an instance of type ILogger ). Note that mapping interfaces to a specific implementation is only necessary if the interface has multiple configured implementations. If the interface has a single configured implementation, DIE will automatically choose it. With multiple implementations, a manual choice of the configured implementation is required, but that is a more advanced topic. Generated Code Let's have a look at the generated code: #nullable enable namespace MrMeeseeks.DIE.Samples.GettingStarted { sealed partial class Container : global::MrMeeseeks.DIE.Samples.GettingStarted.Container.ITransientScope_0_11, global::System.IAsyncDisposable, global::System.IDisposable { public static global::MrMeeseeks.DIE.Samples.GettingStarted.Container DIE_CreateContainer() { global::MrMeeseeks.DIE.Samples.GettingStarted.Container container_0_10 = new global::MrMeeseeks.DIE.Samples.GettingStarted.Container(); return container_0_10; } internal global::MrMeeseeks.DIE.Samples.GettingStarted.MrMeeseeks Create() { if (Disposed_0_2) throw new System.ObjectDisposedException(\"global::MrMeeseeks.DIE.Samples.GettingStarted.Container\", $\"[DIE] This scope \\\"global::MrMeeseeks.DIE.Samples.GettingStarted.Container\\\" is already disposed, so it can't create a \\\"global::MrMeeseeks.DIE.Samples.GettingStarted.MrMeeseeks\\\" instance anymore.\"); global::MrMeeseeks.DIE.Samples.GettingStarted.MrMeeseeks functionCallResult_2_1 = (global::MrMeeseeks.DIE.Samples.GettingStarted.MrMeeseeks)CreateMrMeeseeks_2_0(); if (Disposed_0_2) throw new System.ObjectDisposedException(\"global::MrMeeseeks.DIE.Samples.GettingStarted.Container\", $\"[DIE] This scope \\\"global::MrMeeseeks.DIE.Samples.GettingStarted.Container\\\" is already disposed, so it can't create a \\\"global::MrMeeseeks.DIE.Samples.GettingStarted.MrMeeseeks\\\" instance anymore.\"); return functionCallResult_2_1; } private global::MrMeeseeks.DIE.Samples.GettingStarted.MrMeeseeks CreateMrMeeseeks_2_0() { global::MrMeeseeks.DIE.Samples.GettingStarted.Logger logger_2_4 = new global::MrMeeseeks.DIE.Samples.GettingStarted.Logger(); global::MrMeeseeks.DIE.Samples.GettingStarted.ILogger iLogger_2_3 = (global::MrMeeseeks.DIE.Samples.GettingStarted.ILogger)logger_2_4; global::MrMeeseeks.DIE.Samples.GettingStarted.MrMeeseeks mrMeeseeks_2_2 = new global::MrMeeseeks.DIE.Samples.GettingStarted.MrMeeseeks(logger: iLogger_2_3); return mrMeeseeks_2_2; } private global::System.Collections.Concurrent.ConcurrentBag<global::System.IAsyncDisposable> concurrentBag_0_7 = new global::System.Collections.Concurrent.ConcurrentBag<global::System.IAsyncDisposable>(); private global::System.Collections.Concurrent.ConcurrentBag<global::System.IDisposable> concurrentBag_0_6 = new global::System.Collections.Concurrent.ConcurrentBag<global::System.IDisposable>(); private int _disposed_0_0 = 0; private bool Disposed_0_2 => _disposed_0_0 != 0; public async global::System.Threading.Tasks.ValueTask DisposeAsync() { var disposed_0_1 = global::System.Threading.Interlocked.Exchange(ref _disposed_0_0, 1); if (disposed_0_1 != 0) return; global::System.Collections.Generic.List<global::System.Exception> aggregateException_0_4 = new global::System.Collections.Generic.List<global::System.Exception>(); try { while (transientScopeDisposal_0_8.Count > 0) { var transientScopeToDispose_0_9 = System.Linq.Enumerable.FirstOrDefault(transientScopeDisposal_0_8.Keys); if (transientScopeToDispose_0_9 is not null && transientScopeDisposal_0_8.TryRemove(transientScopeToDispose_0_9, out _)) { try { (transientScopeToDispose_0_9 as global::System.IDisposable)?.Dispose(); } catch (global::System.Exception exceptionToAggregate_0_5) { // catch and aggregate so other disposals are triggered aggregateException_0_4.Add(exceptionToAggregate_0_5); } } } transientScopeDisposal_0_8.Clear(); while (concurrentBag_0_7.Count > 0 && concurrentBag_0_7.TryTake(out var iDisposable_0_3)) { try { await iDisposable_0_3.DisposeAsync(); } catch (global::System.Exception exceptionToAggregate_0_5) { // catch and aggregate so other disposals are triggered aggregateException_0_4.Add(exceptionToAggregate_0_5); } } while (concurrentBag_0_6.Count > 0 && concurrentBag_0_6.TryTake(out var iDisposable_0_3)) { try { iDisposable_0_3.Dispose(); } catch (global::System.Exception exceptionToAggregate_0_5) { // catch and aggregate so other disposals are triggered aggregateException_0_4.Add(exceptionToAggregate_0_5); } } } finally { } if (aggregateException_0_4.Count == 1) throw aggregateException_0_4[0]; else if (aggregateException_0_4.Count > 1) throw new System.AggregateException(aggregateException_0_4); } public void Dispose() { var disposed_0_1 = global::System.Threading.Interlocked.Exchange(ref _disposed_0_0, 1); if (disposed_0_1 != 0) return; global::System.Collections.Generic.List<global::System.Exception> aggregateException_0_4 = new global::System.Collections.Generic.List<global::System.Exception>(); try { while (transientScopeDisposal_0_8.Count > 0) { var transientScopeToDispose_0_9 = System.Linq.Enumerable.FirstOrDefault(transientScopeDisposal_0_8.Keys); if (transientScopeToDispose_0_9 is not null && transientScopeDisposal_0_8.TryRemove(transientScopeToDispose_0_9, out _)) { try { (transientScopeToDispose_0_9 as global::System.IDisposable)?.Dispose(); } catch (global::System.Exception exceptionToAggregate_0_5) { // catch and aggregate so other disposals are triggered aggregateException_0_4.Add(exceptionToAggregate_0_5); } } } transientScopeDisposal_0_8.Clear(); while (concurrentBag_0_7.Count > 0 && concurrentBag_0_7.TryTake(out var iDisposable_0_3)) { try { (iDisposable_0_3 as global::System.IDisposable)?.Dispose(); } catch (global::System.Exception exceptionToAggregate_0_5) { // catch and aggregate so other disposals are triggered aggregateException_0_4.Add(exceptionToAggregate_0_5); } } while (concurrentBag_0_6.Count > 0 && concurrentBag_0_6.TryTake(out var iDisposable_0_3)) { try { iDisposable_0_3.Dispose(); } catch (global::System.Exception exceptionToAggregate_0_5) { // catch and aggregate so other disposals are triggered aggregateException_0_4.Add(exceptionToAggregate_0_5); } } } finally { } if (aggregateException_0_4.Count == 1) throw aggregateException_0_4[0]; else if (aggregateException_0_4.Count > 1) throw new System.AggregateException(aggregateException_0_4); } private global::System.Collections.Concurrent.ConcurrentDictionary<global::System.IDisposable, global::System.IDisposable> transientScopeDisposal_0_8 = new global::System.Collections.Concurrent.ConcurrentDictionary<global::System.IDisposable, global::System.IDisposable>(); private interface ITransientScope_0_11 { } } } #nullable disable If you want to look at the generated code yourself, you should add the following to the .csproj that contains the container: <EmitCompilerGeneratedFiles>true</EmitCompilerGeneratedFiles> <CompilerGeneratedFilesOutputPath>$(BaseIntermediateOutputPath)\\GeneratedFiles</CompilerGeneratedFilesOutputPath> Then a copy of the generated code is placed in obj\\GeneratedFiles\\\u2026 . It is highly recommended to take a look at the generated code if you are interested in learning how DIE works. The generated code doesn't look like much for this small example. However, you have to keep in mind that this is boilerplate code, which can be tedious to write quickly. Instead, with DIE, there is very little configuration that needs to be written. And second, as your projects grow, it's going to become increasingly burdensome to maintain a pure DIE container yourself. A DIE container, on the other hand, can be configured to adapt almost seamlessly to your ongoing changes using convenience features.","title":"Getting Started"},{"location":"getting-started/#getting-started","text":"This tutorial-like section is intended for beginners and users who are completely new to DIE. It's just meant to get you started.","title":"Getting Started"},{"location":"getting-started/#our-first-container","text":"First, we need an implementation that can later be built by the container. We'll start with: namespace GettingStarted; internal class Logger { public void Log(string message) => Console.WriteLine(message); } That's enough for a first small container configuration: using MrMeeseeks.DIE.Configuration.Attributes; namespace GettingStarted; [ImplementationAggregation(typeof(Logger))] [CreateFunction(typeof(Logger), \"Create\")] internal sealed partial class Container { private Container() { } } Here we have our container. The ImplementationAggregation attribute registers our Logger class as an implementation to be considered by the container. The CreateFunction attribute instructs the container to create a Logger Create() function (i.e. a factory method that returns an instance of type Logger). With DIE a container needs to have at least one explicit constructor and all constructors should be private. These are necessary constraints of DIE in order to guarantee intitialization features (which we won't use in this example, however). We are ready to use it: await using var container = GettingStarted.Container.DIE_CreateContainer(); var logger = container.Create(); logger.Log(\"Hello, World!\"); This is it! Probably the simplest example you can think of, but it's a start ;) The await using will asynchronously dispose of the container at the end. In this example it's not necessary because we don't have any disposables in use yet. However, this will prepare the use for future changes. But keep in mind that it's not forced upon you. If you don't need it you can remove it at your own risk of missing to dispose resources. Please note that we don't use the container class constructor directly, but the a generated static function that creates a container instance via that constructor. If we would use the before mentioned initialization features, then they would be placed at this static function and therefore guaranteed to be processed as well.","title":"Our First Container"},{"location":"getting-started/#making-it-dependency-injection-idiomatic","text":"Let's spice things up a bit. With dependency injection, in most cases it's better style to depend on interfaces (abstractions) rather than concrete classes (implementations). So what do we need to change? Let's start with the Logger class again: namespace GettingStarted; public interface ILogger { void Log(string message); } internal class Logger : ILogger { public void Log(string message) => Console.WriteLine(message); } And now a class that depends on it: namespace GettingStarted; internal interface IMrMeeseeks { void Greet(); } internal class MrMeeseeks : IMrMeeseeks { private readonly ILogger _logger; internal MrMeeseeks(ILogger logger) => _logger = logger; public void Greet() => _logger.Log(\"I'm MrMeeseeks! Look at me!\"); } Some adjustments to the container, \u2026 using MrMeeseeks.DIE.Configuration.Attributes; namespace GettingStarted; [ImplementationAggregation( typeof(Logger), typeof(MrMeeseeks))] [CreateFunction(typeof(MrMeeseeks), \"Create\")] internal sealed partial class Container { } \u2026 and using it: using var container = new GettingStarted.Container(); var mrMeeseeks = container.Create(); mrMeeseeks.Greet(); Now we are using abstractions and have a true dependency (i.e. MrMeeseeks depends on an instance of type ILogger ). Note that mapping interfaces to a specific implementation is only necessary if the interface has multiple configured implementations. If the interface has a single configured implementation, DIE will automatically choose it. With multiple implementations, a manual choice of the configured implementation is required, but that is a more advanced topic.","title":"Making It Dependency Injection Idiomatic"},{"location":"getting-started/#generated-code","text":"Let's have a look at the generated code: #nullable enable namespace MrMeeseeks.DIE.Samples.GettingStarted { sealed partial class Container : global::MrMeeseeks.DIE.Samples.GettingStarted.Container.ITransientScope_0_11, global::System.IAsyncDisposable, global::System.IDisposable { public static global::MrMeeseeks.DIE.Samples.GettingStarted.Container DIE_CreateContainer() { global::MrMeeseeks.DIE.Samples.GettingStarted.Container container_0_10 = new global::MrMeeseeks.DIE.Samples.GettingStarted.Container(); return container_0_10; } internal global::MrMeeseeks.DIE.Samples.GettingStarted.MrMeeseeks Create() { if (Disposed_0_2) throw new System.ObjectDisposedException(\"global::MrMeeseeks.DIE.Samples.GettingStarted.Container\", $\"[DIE] This scope \\\"global::MrMeeseeks.DIE.Samples.GettingStarted.Container\\\" is already disposed, so it can't create a \\\"global::MrMeeseeks.DIE.Samples.GettingStarted.MrMeeseeks\\\" instance anymore.\"); global::MrMeeseeks.DIE.Samples.GettingStarted.MrMeeseeks functionCallResult_2_1 = (global::MrMeeseeks.DIE.Samples.GettingStarted.MrMeeseeks)CreateMrMeeseeks_2_0(); if (Disposed_0_2) throw new System.ObjectDisposedException(\"global::MrMeeseeks.DIE.Samples.GettingStarted.Container\", $\"[DIE] This scope \\\"global::MrMeeseeks.DIE.Samples.GettingStarted.Container\\\" is already disposed, so it can't create a \\\"global::MrMeeseeks.DIE.Samples.GettingStarted.MrMeeseeks\\\" instance anymore.\"); return functionCallResult_2_1; } private global::MrMeeseeks.DIE.Samples.GettingStarted.MrMeeseeks CreateMrMeeseeks_2_0() { global::MrMeeseeks.DIE.Samples.GettingStarted.Logger logger_2_4 = new global::MrMeeseeks.DIE.Samples.GettingStarted.Logger(); global::MrMeeseeks.DIE.Samples.GettingStarted.ILogger iLogger_2_3 = (global::MrMeeseeks.DIE.Samples.GettingStarted.ILogger)logger_2_4; global::MrMeeseeks.DIE.Samples.GettingStarted.MrMeeseeks mrMeeseeks_2_2 = new global::MrMeeseeks.DIE.Samples.GettingStarted.MrMeeseeks(logger: iLogger_2_3); return mrMeeseeks_2_2; } private global::System.Collections.Concurrent.ConcurrentBag<global::System.IAsyncDisposable> concurrentBag_0_7 = new global::System.Collections.Concurrent.ConcurrentBag<global::System.IAsyncDisposable>(); private global::System.Collections.Concurrent.ConcurrentBag<global::System.IDisposable> concurrentBag_0_6 = new global::System.Collections.Concurrent.ConcurrentBag<global::System.IDisposable>(); private int _disposed_0_0 = 0; private bool Disposed_0_2 => _disposed_0_0 != 0; public async global::System.Threading.Tasks.ValueTask DisposeAsync() { var disposed_0_1 = global::System.Threading.Interlocked.Exchange(ref _disposed_0_0, 1); if (disposed_0_1 != 0) return; global::System.Collections.Generic.List<global::System.Exception> aggregateException_0_4 = new global::System.Collections.Generic.List<global::System.Exception>(); try { while (transientScopeDisposal_0_8.Count > 0) { var transientScopeToDispose_0_9 = System.Linq.Enumerable.FirstOrDefault(transientScopeDisposal_0_8.Keys); if (transientScopeToDispose_0_9 is not null && transientScopeDisposal_0_8.TryRemove(transientScopeToDispose_0_9, out _)) { try { (transientScopeToDispose_0_9 as global::System.IDisposable)?.Dispose(); } catch (global::System.Exception exceptionToAggregate_0_5) { // catch and aggregate so other disposals are triggered aggregateException_0_4.Add(exceptionToAggregate_0_5); } } } transientScopeDisposal_0_8.Clear(); while (concurrentBag_0_7.Count > 0 && concurrentBag_0_7.TryTake(out var iDisposable_0_3)) { try { await iDisposable_0_3.DisposeAsync(); } catch (global::System.Exception exceptionToAggregate_0_5) { // catch and aggregate so other disposals are triggered aggregateException_0_4.Add(exceptionToAggregate_0_5); } } while (concurrentBag_0_6.Count > 0 && concurrentBag_0_6.TryTake(out var iDisposable_0_3)) { try { iDisposable_0_3.Dispose(); } catch (global::System.Exception exceptionToAggregate_0_5) { // catch and aggregate so other disposals are triggered aggregateException_0_4.Add(exceptionToAggregate_0_5); } } } finally { } if (aggregateException_0_4.Count == 1) throw aggregateException_0_4[0]; else if (aggregateException_0_4.Count > 1) throw new System.AggregateException(aggregateException_0_4); } public void Dispose() { var disposed_0_1 = global::System.Threading.Interlocked.Exchange(ref _disposed_0_0, 1); if (disposed_0_1 != 0) return; global::System.Collections.Generic.List<global::System.Exception> aggregateException_0_4 = new global::System.Collections.Generic.List<global::System.Exception>(); try { while (transientScopeDisposal_0_8.Count > 0) { var transientScopeToDispose_0_9 = System.Linq.Enumerable.FirstOrDefault(transientScopeDisposal_0_8.Keys); if (transientScopeToDispose_0_9 is not null && transientScopeDisposal_0_8.TryRemove(transientScopeToDispose_0_9, out _)) { try { (transientScopeToDispose_0_9 as global::System.IDisposable)?.Dispose(); } catch (global::System.Exception exceptionToAggregate_0_5) { // catch and aggregate so other disposals are triggered aggregateException_0_4.Add(exceptionToAggregate_0_5); } } } transientScopeDisposal_0_8.Clear(); while (concurrentBag_0_7.Count > 0 && concurrentBag_0_7.TryTake(out var iDisposable_0_3)) { try { (iDisposable_0_3 as global::System.IDisposable)?.Dispose(); } catch (global::System.Exception exceptionToAggregate_0_5) { // catch and aggregate so other disposals are triggered aggregateException_0_4.Add(exceptionToAggregate_0_5); } } while (concurrentBag_0_6.Count > 0 && concurrentBag_0_6.TryTake(out var iDisposable_0_3)) { try { iDisposable_0_3.Dispose(); } catch (global::System.Exception exceptionToAggregate_0_5) { // catch and aggregate so other disposals are triggered aggregateException_0_4.Add(exceptionToAggregate_0_5); } } } finally { } if (aggregateException_0_4.Count == 1) throw aggregateException_0_4[0]; else if (aggregateException_0_4.Count > 1) throw new System.AggregateException(aggregateException_0_4); } private global::System.Collections.Concurrent.ConcurrentDictionary<global::System.IDisposable, global::System.IDisposable> transientScopeDisposal_0_8 = new global::System.Collections.Concurrent.ConcurrentDictionary<global::System.IDisposable, global::System.IDisposable>(); private interface ITransientScope_0_11 { } } } #nullable disable If you want to look at the generated code yourself, you should add the following to the .csproj that contains the container: <EmitCompilerGeneratedFiles>true</EmitCompilerGeneratedFiles> <CompilerGeneratedFilesOutputPath>$(BaseIntermediateOutputPath)\\GeneratedFiles</CompilerGeneratedFilesOutputPath> Then a copy of the generated code is placed in obj\\GeneratedFiles\\\u2026 . It is highly recommended to take a look at the generated code if you are interested in learning how DIE works. The generated code doesn't look like much for this small example. However, you have to keep in mind that this is boilerplate code, which can be tedious to write quickly. Instead, with DIE, there is very little configuration that needs to be written. And second, as your projects grow, it's going to become increasingly burdensome to maintain a pure DIE container yourself. A DIE container, on the other hand, can be configured to adapt almost seamlessly to your ongoing changes using convenience features.","title":"Generated Code"},{"location":"glossary/","text":"Glossary Abstraction An abstraction is an interface or class. Every class is also an abstraction, but the focus here is that it is a root of an inheritance hierarchy and therefore potentially represents a larger set of implementations. Collection Injection The term for injecting types like IEnumerable<\u2026> , IReadOnlyList<\u2026> , or IReadOnlyCollection<\u2026> . Container In the context of DIE, it is a class generated by DIE that knows how to instantiate user-selected types. The DIE container uses pure dependency injection, rather than using reflection like more traditional container projects. Depending on the context in this documentation, the term container may also have a generic meaning. Factory Injection The term for injecting types like Lazy<\u2026> or Func<\u2026> . In this context, Lazy<\u2026> can be understood as a parameterless one-time factory. Implementation An implementation is a non-abstract class or a struct or their non-abstract record-variants. Thus, an implementation is a class or struct that can be instantiated by the new operator. Instance Injection An injection for an ordinary type with an ordinary instance. Scope Injection An injection that starts a new scope or transient scope. The instances injected are scope or transient scope roots.","title":"Glossary"},{"location":"glossary/#glossary","text":"Abstraction An abstraction is an interface or class. Every class is also an abstraction, but the focus here is that it is a root of an inheritance hierarchy and therefore potentially represents a larger set of implementations. Collection Injection The term for injecting types like IEnumerable<\u2026> , IReadOnlyList<\u2026> , or IReadOnlyCollection<\u2026> . Container In the context of DIE, it is a class generated by DIE that knows how to instantiate user-selected types. The DIE container uses pure dependency injection, rather than using reflection like more traditional container projects. Depending on the context in this documentation, the term container may also have a generic meaning. Factory Injection The term for injecting types like Lazy<\u2026> or Func<\u2026> . In this context, Lazy<\u2026> can be understood as a parameterless one-time factory. Implementation An implementation is a non-abstract class or a struct or their non-abstract record-variants. Thus, an implementation is a class or struct that can be instantiated by the new operator. Instance Injection An injection for an ordinary type with an ordinary instance. Scope Injection An injection that starts a new scope or transient scope. The instances injected are scope or transient scope roots.","title":"Glossary"},{"location":"initializers/","text":"Initializers .Net's instantiation process is basically just the constructor call and object initialization (property injection). There are two problems with such a process: You can't work with dependencies injected to properties via the object initializer in the instantiation process, because the constructor is called before the object initializer. You are forced to do a synchronous instantiation because .Net constructors are synchronous only. The initializer feature is intended to solve these issues. It lets you declare which function of which type should be called as the initialization method. There are some restrictions on the initialization methods: They can only return either void , ValueTask or Task . They must be non-static There should be only one declared initializer method per implementation. DIE guarantees to call the initializer method exactly once. For the sync initializers, DIE guarantees that the initializer method will be executed to completion before the associated instance is injected into other instances. The behavior of the async initializer is a bit more complex. If the associated instance is injected via wrapping into a ValueTask<\u2026> or a Task<\u2026> , then it is injected as soon as the initialization task does the async return (await), and the task wrapper is guaranteed to complete asynchronously exactly when the initializer's task completes. If the associated instance is injected bare (without a task wrapper), then the initializer's task is guaranteed to await and therefore complete before the associated instance is injected further. The initializers can be declared either for abstractions or for implementations. Explicit Implementation Trick This is only a recommendation, as it is probably a matter of taste. If you are using an interface for the initializers, then make it an explicit implementation in the implementation types. The advantage of this approach is that in this case you can't reach the initializer method without explicitly casting to the interface type. Since the initializer method should only be called once, and only by the container, you don't need to call it regularly anyway. internal class Dependency : ITypeInitializer { void ITypeInitializer.Initialize() { // initialization logic } }","title":"Initializers"},{"location":"initializers/#initializers","text":".Net's instantiation process is basically just the constructor call and object initialization (property injection). There are two problems with such a process: You can't work with dependencies injected to properties via the object initializer in the instantiation process, because the constructor is called before the object initializer. You are forced to do a synchronous instantiation because .Net constructors are synchronous only. The initializer feature is intended to solve these issues. It lets you declare which function of which type should be called as the initialization method. There are some restrictions on the initialization methods: They can only return either void , ValueTask or Task . They must be non-static There should be only one declared initializer method per implementation. DIE guarantees to call the initializer method exactly once. For the sync initializers, DIE guarantees that the initializer method will be executed to completion before the associated instance is injected into other instances. The behavior of the async initializer is a bit more complex. If the associated instance is injected via wrapping into a ValueTask<\u2026> or a Task<\u2026> , then it is injected as soon as the initialization task does the async return (await), and the task wrapper is guaranteed to complete asynchronously exactly when the initializer's task completes. If the associated instance is injected bare (without a task wrapper), then the initializer's task is guaranteed to await and therefore complete before the associated instance is injected further. The initializers can be declared either for abstractions or for implementations.","title":"Initializers"},{"location":"initializers/#explicit-implementation-trick","text":"This is only a recommendation, as it is probably a matter of taste. If you are using an interface for the initializers, then make it an explicit implementation in the implementation types. The advantage of this approach is that in this case you can't reach the initializer method without explicitly casting to the interface type. Since the initializer method should only be called once, and only by the container, you don't need to call it regularly anyway. internal class Dependency : ITypeInitializer { void ITypeInitializer.Initialize() { // initialization logic } }","title":"Explicit Implementation Trick"},{"location":"injections/","text":"Injections DIE supports several types of injections: Instance injection Collection injection Factory injection Scope injection This page explains how to work with these injections. Instance Injection Instance injections are ordinary dependency injections. That is, you declare what type you need, and you'll get a single instance of that type. Instance injections can be divided into two different parts. One is injection of implementation types, and the other is injection of abstraction types. Understanding DIE's definition of an implementation type and an abstraction type is necessary to understand when to use which injection behavior. Definition: Implementation types Non-abstract class types Including non-abstract record types Struct types Including struct record types Abstraction types Interface types Abstract class types Including abstract record types Implementations Example: internal record Dependency; internal class DependencyHolder { internal readonly Dependency _dependency; internal DependencyHolder(Dependency dependency) => // is an instance of type Dependency _dependency = dependency; } By default, whenever an implementation type needs to be injected, DIE will inject an instance of exactly that type. This is true even if the implementation type is a parent class that has inheriting child classes. However, there is a way to modify this behavior by configuring implementation choices. Alternatively, user-defined factories can be used to change this behavior as well. Abstraction Example: internal interface IDependency {} internal record Dependency : IDependency; internal class DependencyHolder { internal readonly IDependency _dependency; internal DependencyHolder(IDependency dependency) => // is an instance of type Dependency _dependency = dependency; } Whenever an abstraction type (interface or abstract class) needs to be injected, DIE will by default use the only known implementation type that implements the abstraction in its place. If multiple implementations are known, then using configuration features such as implementation choice or a user-defined factory is mandatory to uniquely select an implementation. Nullability Example: internal interface IDependency {} internal class DependencyHolder { internal readonly IDependency? _dependency; internal DependencyHolder(IDependency? dependency) => // is null _dependency = dependency; } If the dependency type is a nullable abstraction type and DIE can't choose a unique implementation (no implementations; multiple implementations; no implementation choice), then DIE will inject the null value instead. Generics Example: internal record Dependency<T>; internal class DependencyHolder { internal readonly Dependency<int> _dependency; internal DependencyHolder(Dependency<int> dependency) => // is an instance of type Dependency<int> _dependency = dependency; } Instance injection supports generic types (see the generics support page ). Collection Injection Example: internal interface IDependency {} internal record DependencyA : IDependency; internal record DependencyB : IDependency; internal class DependencyHolder { internal readonly IReadOnlyList<IDependency> _dependencies; internal DependencyHolder(IReadOnlyList<IDependency> dependencies) => // is a collection of a DependencyA- and a DependencyB-instance _dependencies = dependencies; } Collection injections aren't limited to injecting a single implementation. Therefore, the injected instance will be a collection type that contains instances for each different implementation of its member type as items. The currently supported collection types are IEnumerable<\u2026> IAsyncEnumerable<\u2026> Arrays IList<\u2026> ICollection<\u2026> ReadOnlyCollection<\u2026> IReadOnlyCollection<\u2026> IReadOnlyList<\u2026> ArraySegment<\u2026> ConcurrentBag<\u2026> ConcurrentQueue<\u2026> ConcurrentStack<\u2026> HashSet<\u2026> LinkedList<\u2026> List<\u2026> Queue<\u2026> SortedSet<\u2026> Stack<\u2026> ImmutableArray<\u2026> ImmutableHashSet<\u2026> ImmutableList<\u2026> ImmutableQueue<\u2026> ImmutableSortedSet<\u2026> ImmutableStack<\u2026> If you want to restrict the implementations of collection injection that are used, you can use an implementation collection choice as a configuration option. IEnumerable<\u2026> and IAsyncEnumerable<\u2026> injections are lazy evaluated. That means, the item instances are created one at a time as they get pulled out by iteration. However, there is one exception to the lazy evaluation. That is with an IEnumerable<\u2026> injection which is asynchronous, meaning that it needs to perform one or more awaits. In that case the items will be gathered in an array and returned as IEnumerable<\u2026> . You can also combine the collection types with ValueTask<\u2026> or Task<\u2026> (e.g. ValueTask<IReadOnlyList<IDependency>> ), if you might need to wrap asynchronous resolutions of one or multiple implementations. Factory Injection Instead of injecting the dependency directly with factory injections, you have the option to inject generated factories that will create the dependencies on demand. DIE supports Func<\u2026> and Lazy<\u2026> as factory wrapper types. The created dependency type (the last generic parameter for Func<\u2026> and the only generic parameter for Lazy<\u2026> ) can be any other type of injection (i.e. instance, collection, or scope injection). Once the scope in which the factory was instantiated is disposed of, no further use of the factory is allowed. If the factory is still called from a disposed scope, it will throw an exception. Func Example: internal record Dependency(int Number, string Text); internal class DependencyHolder { internal readonly Func<int, string, Dependency> _dependencyFactory; internal DependencyHolder(Func<int, string, Dependency> dependencyFactory) => // is a factory that creates an instance of type Dependency _dependencyFactory = dependencyFactory; } The parameters of a Func<\u2026> factory are also supported. The parameters are used as overrides for the remaining resolution, if not overridden again later. The override semantic is inspired by another great DI container: Shout out to DryIoc ! Lazy Example: internal record Dependency(int Number, string Text); internal class DependencyHolder { internal readonly Lazy<Dependency> _dependency; internal DependencyHolder(Lazy<Dependency> dependency) => // is a lazy object that creates an instance of type Dependency upon first usage _dependency = dependency; } While technically not being a functor (\"first-citizen function\") itself, Lazy<\u2026> s get a functor injected which they then use. In DIE, Lazy<\u2026> s are interpreted as parameterless factories that can only create a single instance, but where the creation can be delayed until the first use. Scope Injection Example: internal record Dependency; internal record ScopeRoot(Dependency Dependency) : IScopeRoot; internal class DependencyHolder { internal readonly ScopeRoot _scopeRoot; internal DependencyHolder(ScopeRoot scopeRoot) => // Starts a new scope in which the ScopeRoot- and the Dependency-instance is created _scopeRoot = scopeRoot; } Scope injection is very similar to instance injection from a usage perspective. The difference is that scope injection starts a new (transient) scope and creates the injected instance (called the scope root) from it. For a more complete explanation, see the scoping page . (Value)Tuple Example: internal record DependencyA; internal record DependencyB; internal class DependencyHolder { internal readonly (DependencyA, DependencyB) _tuple; internal DependencyHolder((DependencyA, DependencyB) tuple) => // is a tuple of a DependencyA- and a DependencyB-instance _tuple = tuple; } Tuple injection can be seen as a special case, because it can be understood as a combination of injections. For each type of the tuple, a separate resolution is started, very similar to what would have happened in an ordinary dependency injection. The result of these resolutions is assembled into the tuple. DIE supports Tuple<\u2026> and both the syntax and non-syntax ValueTuple<\u2026> .","title":"Injections"},{"location":"injections/#injections","text":"DIE supports several types of injections: Instance injection Collection injection Factory injection Scope injection This page explains how to work with these injections.","title":"Injections"},{"location":"injections/#instance-injection","text":"Instance injections are ordinary dependency injections. That is, you declare what type you need, and you'll get a single instance of that type. Instance injections can be divided into two different parts. One is injection of implementation types, and the other is injection of abstraction types. Understanding DIE's definition of an implementation type and an abstraction type is necessary to understand when to use which injection behavior. Definition: Implementation types Non-abstract class types Including non-abstract record types Struct types Including struct record types Abstraction types Interface types Abstract class types Including abstract record types","title":"Instance Injection"},{"location":"injections/#implementations","text":"Example: internal record Dependency; internal class DependencyHolder { internal readonly Dependency _dependency; internal DependencyHolder(Dependency dependency) => // is an instance of type Dependency _dependency = dependency; } By default, whenever an implementation type needs to be injected, DIE will inject an instance of exactly that type. This is true even if the implementation type is a parent class that has inheriting child classes. However, there is a way to modify this behavior by configuring implementation choices. Alternatively, user-defined factories can be used to change this behavior as well.","title":"Implementations"},{"location":"injections/#abstraction","text":"Example: internal interface IDependency {} internal record Dependency : IDependency; internal class DependencyHolder { internal readonly IDependency _dependency; internal DependencyHolder(IDependency dependency) => // is an instance of type Dependency _dependency = dependency; } Whenever an abstraction type (interface or abstract class) needs to be injected, DIE will by default use the only known implementation type that implements the abstraction in its place. If multiple implementations are known, then using configuration features such as implementation choice or a user-defined factory is mandatory to uniquely select an implementation.","title":"Abstraction"},{"location":"injections/#nullability","text":"Example: internal interface IDependency {} internal class DependencyHolder { internal readonly IDependency? _dependency; internal DependencyHolder(IDependency? dependency) => // is null _dependency = dependency; } If the dependency type is a nullable abstraction type and DIE can't choose a unique implementation (no implementations; multiple implementations; no implementation choice), then DIE will inject the null value instead.","title":"Nullability"},{"location":"injections/#generics","text":"Example: internal record Dependency<T>; internal class DependencyHolder { internal readonly Dependency<int> _dependency; internal DependencyHolder(Dependency<int> dependency) => // is an instance of type Dependency<int> _dependency = dependency; } Instance injection supports generic types (see the generics support page ).","title":"Generics"},{"location":"injections/#collection-injection","text":"Example: internal interface IDependency {} internal record DependencyA : IDependency; internal record DependencyB : IDependency; internal class DependencyHolder { internal readonly IReadOnlyList<IDependency> _dependencies; internal DependencyHolder(IReadOnlyList<IDependency> dependencies) => // is a collection of a DependencyA- and a DependencyB-instance _dependencies = dependencies; } Collection injections aren't limited to injecting a single implementation. Therefore, the injected instance will be a collection type that contains instances for each different implementation of its member type as items. The currently supported collection types are IEnumerable<\u2026> IAsyncEnumerable<\u2026> Arrays IList<\u2026> ICollection<\u2026> ReadOnlyCollection<\u2026> IReadOnlyCollection<\u2026> IReadOnlyList<\u2026> ArraySegment<\u2026> ConcurrentBag<\u2026> ConcurrentQueue<\u2026> ConcurrentStack<\u2026> HashSet<\u2026> LinkedList<\u2026> List<\u2026> Queue<\u2026> SortedSet<\u2026> Stack<\u2026> ImmutableArray<\u2026> ImmutableHashSet<\u2026> ImmutableList<\u2026> ImmutableQueue<\u2026> ImmutableSortedSet<\u2026> ImmutableStack<\u2026> If you want to restrict the implementations of collection injection that are used, you can use an implementation collection choice as a configuration option. IEnumerable<\u2026> and IAsyncEnumerable<\u2026> injections are lazy evaluated. That means, the item instances are created one at a time as they get pulled out by iteration. However, there is one exception to the lazy evaluation. That is with an IEnumerable<\u2026> injection which is asynchronous, meaning that it needs to perform one or more awaits. In that case the items will be gathered in an array and returned as IEnumerable<\u2026> . You can also combine the collection types with ValueTask<\u2026> or Task<\u2026> (e.g. ValueTask<IReadOnlyList<IDependency>> ), if you might need to wrap asynchronous resolutions of one or multiple implementations.","title":"Collection Injection"},{"location":"injections/#factory-injection","text":"Instead of injecting the dependency directly with factory injections, you have the option to inject generated factories that will create the dependencies on demand. DIE supports Func<\u2026> and Lazy<\u2026> as factory wrapper types. The created dependency type (the last generic parameter for Func<\u2026> and the only generic parameter for Lazy<\u2026> ) can be any other type of injection (i.e. instance, collection, or scope injection). Once the scope in which the factory was instantiated is disposed of, no further use of the factory is allowed. If the factory is still called from a disposed scope, it will throw an exception.","title":"Factory Injection"},{"location":"injections/#func","text":"Example: internal record Dependency(int Number, string Text); internal class DependencyHolder { internal readonly Func<int, string, Dependency> _dependencyFactory; internal DependencyHolder(Func<int, string, Dependency> dependencyFactory) => // is a factory that creates an instance of type Dependency _dependencyFactory = dependencyFactory; } The parameters of a Func<\u2026> factory are also supported. The parameters are used as overrides for the remaining resolution, if not overridden again later. The override semantic is inspired by another great DI container: Shout out to DryIoc !","title":"Func"},{"location":"injections/#lazy","text":"Example: internal record Dependency(int Number, string Text); internal class DependencyHolder { internal readonly Lazy<Dependency> _dependency; internal DependencyHolder(Lazy<Dependency> dependency) => // is a lazy object that creates an instance of type Dependency upon first usage _dependency = dependency; } While technically not being a functor (\"first-citizen function\") itself, Lazy<\u2026> s get a functor injected which they then use. In DIE, Lazy<\u2026> s are interpreted as parameterless factories that can only create a single instance, but where the creation can be delayed until the first use.","title":"Lazy"},{"location":"injections/#scope-injection","text":"Example: internal record Dependency; internal record ScopeRoot(Dependency Dependency) : IScopeRoot; internal class DependencyHolder { internal readonly ScopeRoot _scopeRoot; internal DependencyHolder(ScopeRoot scopeRoot) => // Starts a new scope in which the ScopeRoot- and the Dependency-instance is created _scopeRoot = scopeRoot; } Scope injection is very similar to instance injection from a usage perspective. The difference is that scope injection starts a new (transient) scope and creates the injected instance (called the scope root) from it. For a more complete explanation, see the scoping page .","title":"Scope Injection"},{"location":"injections/#valuetuple","text":"Example: internal record DependencyA; internal record DependencyB; internal class DependencyHolder { internal readonly (DependencyA, DependencyB) _tuple; internal DependencyHolder((DependencyA, DependencyB) tuple) => // is a tuple of a DependencyA- and a DependencyB-instance _tuple = tuple; } Tuple injection can be seen as a special case, because it can be understood as a combination of injections. For each type of the tuple, a separate resolution is started, very similar to what would have happened in an ordinary dependency injection. The result of these resolutions is assembled into the tuple. DIE supports Tuple<\u2026> and both the syntax and non-syntax ValueTuple<\u2026> .","title":"(Value)Tuple"},{"location":"naming-rules/","text":"Naming Rules Container classes (i.e. classes that have at least one CreateFunction attribute applied to them) are used by DIE to generate code into them, and can be used by you as a consumer. In principle, you can give this class any member you want. However, to prevent collisions between the member identifiers of the generated code and your code, DIE has some naming rules for container classes. You'll need to follow them, but rest assured that DIE's validation will catch any violation and point you to the offending member. The naming rules don't just apply to container classes, but to (transient) scope classes as well. These are the three levels of naming rules, in descending order of strictness: Member identifiers that you can't use fall into two categories: Don't use identifiers like {number}_{number} or identifiers with the suffix _{number}_{number} on any member. With a few exceptions, all generated code will use this pattern. These patterns are deliberately chosen to be cryptic, so that the prohibition to use them can be tolerated as much as possible. Dispose & DisposeAsync are also reserved for the generated code. If possible, DIE will generate this function, so you are not allowed to do it yourself. If you need to manually append some instances for disposal, you can use the special user-defined elements (see user-defined elements page ). Use member identifiers with the DIE_ prefix for user-defined elements only. To an extend you can chose the name of certain user-defined elements freely. However, there are restrictions that are specific to the type of user-defined element you want to use. For example, user-defined factory methods/properties/fields must start with DIE_Factory ; any letter or number that follows is up to you, as long as you don't break the rules above (see user-defined elements page ). Any identifier that doesn't conform to the above rules is up to you. In this case, DIE guarantees that you will be collision-free with the generated code.","title":"Naming Rules"},{"location":"naming-rules/#naming-rules","text":"Container classes (i.e. classes that have at least one CreateFunction attribute applied to them) are used by DIE to generate code into them, and can be used by you as a consumer. In principle, you can give this class any member you want. However, to prevent collisions between the member identifiers of the generated code and your code, DIE has some naming rules for container classes. You'll need to follow them, but rest assured that DIE's validation will catch any violation and point you to the offending member. The naming rules don't just apply to container classes, but to (transient) scope classes as well. These are the three levels of naming rules, in descending order of strictness: Member identifiers that you can't use fall into two categories: Don't use identifiers like {number}_{number} or identifiers with the suffix _{number}_{number} on any member. With a few exceptions, all generated code will use this pattern. These patterns are deliberately chosen to be cryptic, so that the prohibition to use them can be tolerated as much as possible. Dispose & DisposeAsync are also reserved for the generated code. If possible, DIE will generate this function, so you are not allowed to do it yourself. If you need to manually append some instances for disposal, you can use the special user-defined elements (see user-defined elements page ). Use member identifiers with the DIE_ prefix for user-defined elements only. To an extend you can chose the name of certain user-defined elements freely. However, there are restrictions that are specific to the type of user-defined element you want to use. For example, user-defined factory methods/properties/fields must start with DIE_Factory ; any letter or number that follows is up to you, as long as you don't break the rules above (see user-defined elements page ). Any identifier that doesn't conform to the above rules is up to you. In this case, DIE guarantees that you will be collision-free with the generated code.","title":"Naming Rules"},{"location":"resolution-precedence/","text":"Resolution Precedence During resolution DIE processes the injected types. The resulting resolution (i.e. which kind of injection will take place) depends on the the type and precedence. The first matching rule of the following precendence list will be selected: Special Overrides ( IDisposable or IAsyncDisposable as a transient scope disposal hook or decorated instances or composited instances) Overrides (Func- or Create-Function parameters) User-defined factories ( DIE_Factory -fields, -properties & -functions) Wrapper types ( ValueTask<\u2026> , Task<\u2026> , ValueTuple<\u2026> , Tuple<\u2026> ) Factory types ( Lazy<\u2026> & Func<\u2026> ) Collection types ( IEnumerable<\u2026> , IAsyncEnumerable<\u2026> ,arrays, IReadOnlyList<\u2026> and so on) Abstractions (interface or abstract class types) Implementations (structs or non-abstract class types) Some remarks: The special overrides are contextual. Meaning that this rule is only active in transient scopes (for IDisposable & IAsyncDisposable ) or decorators (for decorated instances) or composites (for composited instances). Wrapper types are resolved by starting the resolution process for its innet type anew. The same behavior applies to factory and collection types. The substitution types for abstraction types will ignore this list and will straigth up resolve as an implementation.","title":"Resolution Precedence"},{"location":"resolution-precedence/#resolution-precedence","text":"During resolution DIE processes the injected types. The resulting resolution (i.e. which kind of injection will take place) depends on the the type and precedence. The first matching rule of the following precendence list will be selected: Special Overrides ( IDisposable or IAsyncDisposable as a transient scope disposal hook or decorated instances or composited instances) Overrides (Func- or Create-Function parameters) User-defined factories ( DIE_Factory -fields, -properties & -functions) Wrapper types ( ValueTask<\u2026> , Task<\u2026> , ValueTuple<\u2026> , Tuple<\u2026> ) Factory types ( Lazy<\u2026> & Func<\u2026> ) Collection types ( IEnumerable<\u2026> , IAsyncEnumerable<\u2026> ,arrays, IReadOnlyList<\u2026> and so on) Abstractions (interface or abstract class types) Implementations (structs or non-abstract class types) Some remarks: The special overrides are contextual. Meaning that this rule is only active in transient scopes (for IDisposable & IAsyncDisposable ) or decorators (for decorated instances) or composites (for composited instances). Wrapper types are resolved by starting the resolution process for its innet type anew. The same behavior applies to factory and collection types. The substitution types for abstraction types will ignore this list and will straigth up resolve as an implementation.","title":"Resolution Precedence"},{"location":"samples/","text":"Samples This page highlights existing sample projects that interested people are recommended to take a look at. Test Project The test project of DIE contains hundreds of mini containers each of which can be considered as a full-fledged sample. However, the bulk of it would focus on a single feature or aspect of DIE. Therefore, it is a nice source of getting to learn to use a certain feature, but not so much suited as a real-world example. Foot note: DIE also has a project called Sample . However, it is just used as a vehicle to quickly test stuff during development. So consider the containers there as pretty random. Self-Containerization DIE is a complex project, that means it makes sense to use dependency injection with a container there as well. Retorical question: Which container would be suitable for this? - DIE itself, of course. Here is the configuration that builds the container of DIE. The self-containerization of DIE can keep up as a real world sample. For example, it uses the concepts of scope to a great extend. Discontinued Hobby Project The container configuration of a discontinued hobby project of Yeah69 is another sample for a non-simple use case. You can find the configuration here . However, be aware that it might be one of the messiest of the samples.","title":"Samples"},{"location":"samples/#samples","text":"This page highlights existing sample projects that interested people are recommended to take a look at.","title":"Samples"},{"location":"samples/#test-project","text":"The test project of DIE contains hundreds of mini containers each of which can be considered as a full-fledged sample. However, the bulk of it would focus on a single feature or aspect of DIE. Therefore, it is a nice source of getting to learn to use a certain feature, but not so much suited as a real-world example. Foot note: DIE also has a project called Sample . However, it is just used as a vehicle to quickly test stuff during development. So consider the containers there as pretty random.","title":"Test Project"},{"location":"samples/#self-containerization","text":"DIE is a complex project, that means it makes sense to use dependency injection with a container there as well. Retorical question: Which container would be suitable for this? - DIE itself, of course. Here is the configuration that builds the container of DIE. The self-containerization of DIE can keep up as a real world sample. For example, it uses the concepts of scope to a great extend.","title":"Self-Containerization"},{"location":"samples/#discontinued-hobby-project","text":"The container configuration of a discontinued hobby project of Yeah69 is another sample for a non-simple use case. You can find the configuration here . However, be aware that it might be one of the messiest of the samples.","title":"Discontinued Hobby Project"},{"location":"scoping/","text":"Scoping Scoping is a means of subdividing the container. With DIE, there are several reasons to subdivide into scopes: Configuration Scopes can be used to change configurations at the container level. For example, you can use different implementation choices, and scopes can have their own custom elements such as factories. Almost any configuration can be changed at the scope level. Instance Sharing Instances can be shared for scopes instead of the whole container. Collective Disposal Scopes have also their own disposal management. This means that managed disposals instantiated in a scope will be disposed of when the scope is disposed of. Special scopes, called \"transient scopes\", can be used to decouple the disposal from the container disposal and be disposed of eagerly. How to use scopes? The answer to this must be twofold. One is to configure scopes, and the other is to indirectly spawn scopes in the codebase wherever you want. Take this example, which includes both sides of scope usage. internal interface IDependency {} internal class DependencyContainer : IDependency {} internal class DependencyTransientScope : IDependency {} internal class DependencyScope : IDependency {} internal class TransientScope : ITransientScopeRoot { public TransientScope(IDependency dependency) => Dependency = dependency; public IDependency Dependency { get; } } internal class Scope : IScopeRoot { public Scope(IDependency dependency) => Dependency = dependency; public IDependency Dependency { get; } } [TransientScopeRootAbstractionAggregation(typeof(ITransientScopeRoot))] [ScopeRootAbstractionAggregation(typeof(IScopeRoot))] [CreateFunction(typeof(IDependency), \"Create0\")] [CreateFunction(typeof(TransientScope), \"Create1\")] [CreateFunction(typeof(Scope), \"Create2\")] [FilterImplementationAggregation(typeof(DependencyScope))] [FilterImplementationAggregation(typeof(DependencyTransientScope))] internal sealed partial class Container { [FilterImplementationAggregation(typeof(DependencyContainer))] [ImplementationAggregation(typeof(DependencyTransientScope))] private sealed partial class DIE_DefaultTransientScope { } [FilterImplementationAggregation(typeof(DependencyContainer))] [ImplementationAggregation(typeof(DependencyScope))] private sealed partial class DIE_DefaultScope { } } Let's start with configuration. Implicitly, there's always at least one configuration for a default scope and one for a default transient scope. If you want to customize them, you can do so by declaring a nested class DIE_DefaultScope and/or a nested class DIE_DefaultTransientScope in the container class. In the example above, we use the default scope configuration classes to filter and aggregate implementations in such a way that the normal scope and the transient scope would map a different implementation to the IDependency interface. The nested scope configuration classes must be private , sealed , and partial . The other part of using scopes is to define from where in your codebase to start a new scope, and which scope to start. This is done by declaring scope roots. In the example, the marker interface IScopeRoot is used to mark the implementation Scope as the scope root. In general, you could just inject the scope root into any implementation to start a scope there. In this minimalist example, the return type of the create function is the scope root. Therefore, the scope will be the first thing created. Custom Scopes In addition to the default scope and default transient scope, you can also configure custom scopes for scope roots of your choice. See this example: [CreateFunction(typeof(IInterface), \"Create0\")] [CreateFunction(typeof(TransientScopeRoot), \"Create1\")] [CreateFunction(typeof(TransientScopeRootSpecific), \"Create2\")] [CreateFunction(typeof(ScopeRoot), \"Create3\")] [CreateFunction(typeof(ScopeRootSpecific), \"Create4\")] [DecoratorSequenceChoice(typeof(IInterface), typeof(IInterface), typeof(ContainerDecorator))] internal sealed partial class Container { [DecoratorSequenceChoice(typeof(IInterface), typeof(IInterface), typeof(TransientScopeDecorator))] [CustomScopeForRootTypes(typeof(TransientScopeRootSpecific1))] private sealed partial class DIE_TransientScope_A { } [DecoratorSequenceChoice(typeof(IInterface), typeof(IInterface), typeof(TransientScopeSpecificDecorator))] [CustomScopeForRootTypes(typeof(TransientScopeRootSpecific0), typeof(TransientScopeRootSpecific2))] private sealed partial class DIE_TransientScope_B { } [DecoratorSequenceChoice(typeof(IInterface), typeof(IInterface), typeof(ScopeDecorator))] [CustomScopeForRootTypes(typeof(ScopeRootSpecific1))] private sealed partial class DIE_Scope_A { } [DecoratorSequenceChoice(typeof(IInterface), typeof(IInterface), typeof(ScopeSpecificDecorator))] [CustomScopeForRootTypes(typeof(ScopeRootSpecific0), typeof(ScopeRootSpecific1))] private sealed partial class DIE_Scope_B { } } Custom (transient) scopes are declared similarly to the default (transient) scope. However, the custom transient scope identifier must start with DIE_TransientScope and the custom scope identifier must start with DIE_Scope . Also, all custom (transient) scopes must have at least one CustomScopeForRootTypesAttribute attribute with at least one type parameter. The type parameters must be (transient) scope root implementations. On a match, DIE will use the custom (transient) scope instead of the default. It is possible to define a different (transient) scope for each individual (transient) scope root. However, keep in mind that code must be generated for each distinct (transient) scope. This isn't necessarily a bad thing, you may decide it's worth it for your project. Scope Instances Similar to container instances, which are guaranteed to be created once and shared across the entire container, you can configure implementations to be treated as scope instances. As such, they're created once per scope and shared across the scope. In addition to scope instances, there are also transient scope instances. However, the latter have one important difference: they are shared by the entire transient scope and all ordinary scopes created directly or transitively from the transient scope. Containers can also create scope and transient scope instances. This means that in resolution situations where no scope or transient scope has yet been created, the container can effectively act as one. The same principle applies to transient scopes and scope instances. Use Transient Scope Instances Sparingly Transient scope instances are by far the most complex compared to container and scope instances. To understand this, let's first deduce why container instances are simpler. Scopes get an instance of the container injected. This instance is then used by the scope to access the container instances. This is simple because all scopes know only one instance of the container type, so it is very clear what to use. However, the same situation becomes very unclear with transient scopes. A scope can be created under a transient scope or under the container. So when a scope needs to access a transient scope instance, which type should be used? The approach taken for DIE was to introduce an interface for accessing transient scope instances. So instead of a concrete type, scopes get an instance of an interface type injected, so the scope doesn't have to care what type its big parent has. This interface must be implemented by all different transient scopes and by the container. However, this means that, for example, the container must be able to generate functions for transient scope instances even if they aren't used in practice. The same problem applies to all different transient scopes. Because of all this, transient scope instances can be difficult to work with, and they'll result in significantly more generated code than the other types of shared instances. Therefore, it is recommended to use transient scope instances only when you really need them (i.e., when you need to share an instance in the transient scope/container and all its underlying scopes). Configuration Restrictions Configurations such as the container instance configuration only make sense on a container-wide basis. Therefore, they aren't allowed to be used on (transient) scopes. These configurations are Container instance Transient scope instance Transient scope root Scope root Any configurations (aggregation, filtering, implementation, abstraction) that affect these listed aspects aren't allowed on (transient) scopes.","title":"Scoping"},{"location":"scoping/#scoping","text":"Scoping is a means of subdividing the container. With DIE, there are several reasons to subdivide into scopes: Configuration Scopes can be used to change configurations at the container level. For example, you can use different implementation choices, and scopes can have their own custom elements such as factories. Almost any configuration can be changed at the scope level. Instance Sharing Instances can be shared for scopes instead of the whole container. Collective Disposal Scopes have also their own disposal management. This means that managed disposals instantiated in a scope will be disposed of when the scope is disposed of. Special scopes, called \"transient scopes\", can be used to decouple the disposal from the container disposal and be disposed of eagerly.","title":"Scoping"},{"location":"scoping/#how-to-use-scopes","text":"The answer to this must be twofold. One is to configure scopes, and the other is to indirectly spawn scopes in the codebase wherever you want. Take this example, which includes both sides of scope usage. internal interface IDependency {} internal class DependencyContainer : IDependency {} internal class DependencyTransientScope : IDependency {} internal class DependencyScope : IDependency {} internal class TransientScope : ITransientScopeRoot { public TransientScope(IDependency dependency) => Dependency = dependency; public IDependency Dependency { get; } } internal class Scope : IScopeRoot { public Scope(IDependency dependency) => Dependency = dependency; public IDependency Dependency { get; } } [TransientScopeRootAbstractionAggregation(typeof(ITransientScopeRoot))] [ScopeRootAbstractionAggregation(typeof(IScopeRoot))] [CreateFunction(typeof(IDependency), \"Create0\")] [CreateFunction(typeof(TransientScope), \"Create1\")] [CreateFunction(typeof(Scope), \"Create2\")] [FilterImplementationAggregation(typeof(DependencyScope))] [FilterImplementationAggregation(typeof(DependencyTransientScope))] internal sealed partial class Container { [FilterImplementationAggregation(typeof(DependencyContainer))] [ImplementationAggregation(typeof(DependencyTransientScope))] private sealed partial class DIE_DefaultTransientScope { } [FilterImplementationAggregation(typeof(DependencyContainer))] [ImplementationAggregation(typeof(DependencyScope))] private sealed partial class DIE_DefaultScope { } } Let's start with configuration. Implicitly, there's always at least one configuration for a default scope and one for a default transient scope. If you want to customize them, you can do so by declaring a nested class DIE_DefaultScope and/or a nested class DIE_DefaultTransientScope in the container class. In the example above, we use the default scope configuration classes to filter and aggregate implementations in such a way that the normal scope and the transient scope would map a different implementation to the IDependency interface. The nested scope configuration classes must be private , sealed , and partial . The other part of using scopes is to define from where in your codebase to start a new scope, and which scope to start. This is done by declaring scope roots. In the example, the marker interface IScopeRoot is used to mark the implementation Scope as the scope root. In general, you could just inject the scope root into any implementation to start a scope there. In this minimalist example, the return type of the create function is the scope root. Therefore, the scope will be the first thing created.","title":"How to use scopes?"},{"location":"scoping/#custom-scopes","text":"In addition to the default scope and default transient scope, you can also configure custom scopes for scope roots of your choice. See this example: [CreateFunction(typeof(IInterface), \"Create0\")] [CreateFunction(typeof(TransientScopeRoot), \"Create1\")] [CreateFunction(typeof(TransientScopeRootSpecific), \"Create2\")] [CreateFunction(typeof(ScopeRoot), \"Create3\")] [CreateFunction(typeof(ScopeRootSpecific), \"Create4\")] [DecoratorSequenceChoice(typeof(IInterface), typeof(IInterface), typeof(ContainerDecorator))] internal sealed partial class Container { [DecoratorSequenceChoice(typeof(IInterface), typeof(IInterface), typeof(TransientScopeDecorator))] [CustomScopeForRootTypes(typeof(TransientScopeRootSpecific1))] private sealed partial class DIE_TransientScope_A { } [DecoratorSequenceChoice(typeof(IInterface), typeof(IInterface), typeof(TransientScopeSpecificDecorator))] [CustomScopeForRootTypes(typeof(TransientScopeRootSpecific0), typeof(TransientScopeRootSpecific2))] private sealed partial class DIE_TransientScope_B { } [DecoratorSequenceChoice(typeof(IInterface), typeof(IInterface), typeof(ScopeDecorator))] [CustomScopeForRootTypes(typeof(ScopeRootSpecific1))] private sealed partial class DIE_Scope_A { } [DecoratorSequenceChoice(typeof(IInterface), typeof(IInterface), typeof(ScopeSpecificDecorator))] [CustomScopeForRootTypes(typeof(ScopeRootSpecific0), typeof(ScopeRootSpecific1))] private sealed partial class DIE_Scope_B { } } Custom (transient) scopes are declared similarly to the default (transient) scope. However, the custom transient scope identifier must start with DIE_TransientScope and the custom scope identifier must start with DIE_Scope . Also, all custom (transient) scopes must have at least one CustomScopeForRootTypesAttribute attribute with at least one type parameter. The type parameters must be (transient) scope root implementations. On a match, DIE will use the custom (transient) scope instead of the default. It is possible to define a different (transient) scope for each individual (transient) scope root. However, keep in mind that code must be generated for each distinct (transient) scope. This isn't necessarily a bad thing, you may decide it's worth it for your project.","title":"Custom Scopes"},{"location":"scoping/#scope-instances","text":"Similar to container instances, which are guaranteed to be created once and shared across the entire container, you can configure implementations to be treated as scope instances. As such, they're created once per scope and shared across the scope. In addition to scope instances, there are also transient scope instances. However, the latter have one important difference: they are shared by the entire transient scope and all ordinary scopes created directly or transitively from the transient scope. Containers can also create scope and transient scope instances. This means that in resolution situations where no scope or transient scope has yet been created, the container can effectively act as one. The same principle applies to transient scopes and scope instances.","title":"Scope Instances"},{"location":"scoping/#use-transient-scope-instances-sparingly","text":"Transient scope instances are by far the most complex compared to container and scope instances. To understand this, let's first deduce why container instances are simpler. Scopes get an instance of the container injected. This instance is then used by the scope to access the container instances. This is simple because all scopes know only one instance of the container type, so it is very clear what to use. However, the same situation becomes very unclear with transient scopes. A scope can be created under a transient scope or under the container. So when a scope needs to access a transient scope instance, which type should be used? The approach taken for DIE was to introduce an interface for accessing transient scope instances. So instead of a concrete type, scopes get an instance of an interface type injected, so the scope doesn't have to care what type its big parent has. This interface must be implemented by all different transient scopes and by the container. However, this means that, for example, the container must be able to generate functions for transient scope instances even if they aren't used in practice. The same problem applies to all different transient scopes. Because of all this, transient scope instances can be difficult to work with, and they'll result in significantly more generated code than the other types of shared instances. Therefore, it is recommended to use transient scope instances only when you really need them (i.e., when you need to share an instance in the transient scope/container and all its underlying scopes).","title":"Use Transient Scope Instances Sparingly"},{"location":"scoping/#configuration-restrictions","text":"Configurations such as the container instance configuration only make sense on a container-wide basis. Therefore, they aren't allowed to be used on (transient) scopes. These configurations are Container instance Transient scope instance Transient scope root Scope root Any configurations (aggregation, filtering, implementation, abstraction) that affect these listed aspects aren't allowed on (transient) scopes.","title":"Configuration Restrictions"},{"location":"user-defined-elements/","text":"User-Defined Elements User-defined elements are features that allow customization of certain parts of the generated container. User-defined elements must always be defined within the container, transient scope, or scope class. They only apply to the scope in which they are defined, i.e. they don't inherit from the container to child scopes. Factories Factories can be used to shortcut the container and provide custom creation logic. You can choose from three types of factories: methods, properties, or fields. The identifiers of all factories must begin with DIE_Factory . Requirements Identifier starts with DIE_Factory private Non-static Method Non-void Parameters are all ordinary (not out/in/ref/params) Property Has to have a get Field No further requirements Sample [CreateFunction(typeof(Root), \"Create\")] internal sealed partial class Container { private int DIE_Factory_int = 69; private string DIE_Factory_Yeah => \"Yeah\"; private FileInfo DIE_Factory_CurrentFile(ICurrentPath currentPath) => new (currentPath.Value); } Remarks The parameters of method factories are method injections and are created in the same way as regular constructor and property injections, i.e. the same configurations apply. Note that in this case, DIE won't automatically manage the disposables created by the factory. However, you can use the `AddForDisposal' custom element to manually add disposables for disposal management. Constructor Parameters Instead of customizing the creation of a type with an user-defined factory, this will allow you to override certain constructor parameters. Requirements Identifier starts with DIE_ConstrParams private Non-static void UserDefinedConstructorParametersInjection -attribute Two kinds of parameters allowed Ordinary Out parameters each of which has to match a constructor parameter name & type Sample [CreateFunction(typeof(Dependency), \"Create\")] internal sealed partial class Container { [UserDefinedConstructorParametersInjection(typeof(Dependency))] private void DIE_ConstrParam_Dependency(OtherDependency otherDependency, out int number) => number = otherDependency.Number; } Remarks The ordinary parameters are method injections and are created in the same way as regular constructor and property injections, i.e. the same configurations apply. You can match and override multiple constructor parameters Properties Instead of customizing the creation of a type with an user-defined factory, this will allow you to override certain properties. Requirements Identifier starts with DIE_Props private Non-static void UserDefinedPropertiesInjection -attribute Two kinds of parameters allowed Ordinary Out parameters each of which has to match a property name & type Sample [CreateFunction(typeof(Dependency), \"Create\")] internal sealed partial class Container { [UserDefinedPropertiesInjection(typeof(Dependency))] private void DIE_ConstrParam_Dependency(OtherDependency otherDependency, out int Number) => Number = otherDependency.Number; } Remarks The ordinary parameters are method injections and are created in the same way as regular constructor and property injections, i.e. the same configurations apply. You can match and override multiple properties Initializer Parameters Rather than customizing the creation of a type with an user-defined factory, this allows certain initializer parameters to be overridden. Requirements Identifier starts with DIE_InitParams private Non-static void UserDefinedInitializerParametersInjection -attribute Two kinds of parameters allowed Ordinary Out parameters each of which has to match a constructor parameter name & type Sample [CreateFunction(typeof(Dependency), \"Create\")] internal sealed partial class Container { [UserDefinedInitializerParametersInjection(typeof(Dependency))] private void DIE_ConstrParam_Dependency(OtherDependency otherDependency, out int number) => number = otherDependency.Number; } Remarks The ordinary parameters are method injections and are created in the same way as regular constructor and property injections, i.e. the same configurations apply. You can match and override multiple initializer parameters Adding For Disposal You can declare partial methods that can be used to add disposables to the disposal management of the container (or scope). Requirements Identifier should be DIE_AddForDisposal (for IDisposable s) or DIE_AddForDisposalAsync (for IAsyncDisposable s) private Non-static partial void One parameter, either IDisposable or IAsyncDisposable no own implementation Sample [CreateFunction(typeof(Dependency), \"Create\")] internal sealed partial class Container { private Dependency DIE_Factory_Dependency { get { var dependency = new Dependency(); DIE_AddForDisposal(dependency); return dependency; } } private partial void DIE_AddForDisposal(IDisposable disposable); } Remarks When such a function is declared, the container assumes that it has disposables. Therefore, it will always generate the disposal code in that case, even if this user-defined function isn't called once.","title":"User-defined Elements"},{"location":"user-defined-elements/#user-defined-elements","text":"User-defined elements are features that allow customization of certain parts of the generated container. User-defined elements must always be defined within the container, transient scope, or scope class. They only apply to the scope in which they are defined, i.e. they don't inherit from the container to child scopes.","title":"User-Defined Elements"},{"location":"user-defined-elements/#factories","text":"Factories can be used to shortcut the container and provide custom creation logic. You can choose from three types of factories: methods, properties, or fields. The identifiers of all factories must begin with DIE_Factory .","title":"Factories"},{"location":"user-defined-elements/#requirements","text":"Identifier starts with DIE_Factory private Non-static Method Non-void Parameters are all ordinary (not out/in/ref/params) Property Has to have a get Field No further requirements","title":"Requirements"},{"location":"user-defined-elements/#sample","text":"[CreateFunction(typeof(Root), \"Create\")] internal sealed partial class Container { private int DIE_Factory_int = 69; private string DIE_Factory_Yeah => \"Yeah\"; private FileInfo DIE_Factory_CurrentFile(ICurrentPath currentPath) => new (currentPath.Value); }","title":"Sample"},{"location":"user-defined-elements/#remarks","text":"The parameters of method factories are method injections and are created in the same way as regular constructor and property injections, i.e. the same configurations apply. Note that in this case, DIE won't automatically manage the disposables created by the factory. However, you can use the `AddForDisposal' custom element to manually add disposables for disposal management.","title":"Remarks"},{"location":"user-defined-elements/#constructor-parameters","text":"Instead of customizing the creation of a type with an user-defined factory, this will allow you to override certain constructor parameters.","title":"Constructor Parameters"},{"location":"user-defined-elements/#requirements_1","text":"Identifier starts with DIE_ConstrParams private Non-static void UserDefinedConstructorParametersInjection -attribute Two kinds of parameters allowed Ordinary Out parameters each of which has to match a constructor parameter name & type","title":"Requirements"},{"location":"user-defined-elements/#sample_1","text":"[CreateFunction(typeof(Dependency), \"Create\")] internal sealed partial class Container { [UserDefinedConstructorParametersInjection(typeof(Dependency))] private void DIE_ConstrParam_Dependency(OtherDependency otherDependency, out int number) => number = otherDependency.Number; }","title":"Sample"},{"location":"user-defined-elements/#remarks_1","text":"The ordinary parameters are method injections and are created in the same way as regular constructor and property injections, i.e. the same configurations apply. You can match and override multiple constructor parameters","title":"Remarks"},{"location":"user-defined-elements/#properties","text":"Instead of customizing the creation of a type with an user-defined factory, this will allow you to override certain properties.","title":"Properties"},{"location":"user-defined-elements/#requirements_2","text":"Identifier starts with DIE_Props private Non-static void UserDefinedPropertiesInjection -attribute Two kinds of parameters allowed Ordinary Out parameters each of which has to match a property name & type","title":"Requirements"},{"location":"user-defined-elements/#sample_2","text":"[CreateFunction(typeof(Dependency), \"Create\")] internal sealed partial class Container { [UserDefinedPropertiesInjection(typeof(Dependency))] private void DIE_ConstrParam_Dependency(OtherDependency otherDependency, out int Number) => Number = otherDependency.Number; }","title":"Sample"},{"location":"user-defined-elements/#remarks_2","text":"The ordinary parameters are method injections and are created in the same way as regular constructor and property injections, i.e. the same configurations apply. You can match and override multiple properties","title":"Remarks"},{"location":"user-defined-elements/#initializer-parameters","text":"Rather than customizing the creation of a type with an user-defined factory, this allows certain initializer parameters to be overridden.","title":"Initializer Parameters"},{"location":"user-defined-elements/#requirements_3","text":"Identifier starts with DIE_InitParams private Non-static void UserDefinedInitializerParametersInjection -attribute Two kinds of parameters allowed Ordinary Out parameters each of which has to match a constructor parameter name & type","title":"Requirements"},{"location":"user-defined-elements/#sample_3","text":"[CreateFunction(typeof(Dependency), \"Create\")] internal sealed partial class Container { [UserDefinedInitializerParametersInjection(typeof(Dependency))] private void DIE_ConstrParam_Dependency(OtherDependency otherDependency, out int number) => number = otherDependency.Number; }","title":"Sample"},{"location":"user-defined-elements/#remarks_3","text":"The ordinary parameters are method injections and are created in the same way as regular constructor and property injections, i.e. the same configurations apply. You can match and override multiple initializer parameters","title":"Remarks"},{"location":"user-defined-elements/#adding-for-disposal","text":"You can declare partial methods that can be used to add disposables to the disposal management of the container (or scope).","title":"Adding For Disposal"},{"location":"user-defined-elements/#requirements_4","text":"Identifier should be DIE_AddForDisposal (for IDisposable s) or DIE_AddForDisposalAsync (for IAsyncDisposable s) private Non-static partial void One parameter, either IDisposable or IAsyncDisposable no own implementation","title":"Requirements"},{"location":"user-defined-elements/#sample_4","text":"[CreateFunction(typeof(Dependency), \"Create\")] internal sealed partial class Container { private Dependency DIE_Factory_Dependency { get { var dependency = new Dependency(); DIE_AddForDisposal(dependency); return dependency; } } private partial void DIE_AddForDisposal(IDisposable disposable); }","title":"Sample"},{"location":"user-defined-elements/#remarks_4","text":"When such a function is declared, the container assumes that it has disposables. Therefore, it will always generate the disposal code in that case, even if this user-defined function isn't called once.","title":"Remarks"},{"location":"configuration/decorator-composite/","text":"Decorator/Composite Configurations Purpose Since DIE doesn't just assume which implementation is a decorator or a composite, you've got to tell it by - you guessed it :) - configuration. When a decorated interface has more than one decorator, DIE doesn't assume the order in which the decorators should be applied. Therefore, there is an attribute that can be used to configure this as well. Attributes DecoratorAbstractionAggregationAttribute Of each given abstraction, all its implementations are interpreted as decorators. All abstractions are required to have a single generic type parameter. [DecoratorAbstractionAggregation(typeof(IDecorator<>))] FilterDecoratorAbstractionAggregationAttribute Of each given abstraction, all its implementations are stopped being interpreted as decorators. All abstractions are required to have a single generic type parameter. [FilterDecoratorAbstractionAggregation(typeof(IDecorator<>))] DecoratorSequenceChoiceAttribute Selects a sequence of decorators to apply to the decorated implementation. This attribute is mandatory for all decorated implementations that have multiple decorators. A sequence can be configured either for the decorator interface type or for the concrete implementation. The configuration for the interface will be applied to all of its implementations, but if present, the configurations for the concrete implementation will take precedence. First, pass the decorated type interface, then the interface again (for fallback) or decorated implementation type (for specific), and then a list of decorator implementation types. The decorator implementations will be applied in order, that is, the decorated implementation instance will be injected into the first decorator implementation instance, which will be injected into the second, and so on. You can also disable decoration by leaving the list of decorator types empty. [DecoratorSequenceChoice(typeof(IDecorated), typeof(DecoratedImplementation), typeof(DecoratorA), typeof(DecoratorB))] [DecoratorSequenceChoice(typeof(IDecorated), typeof(IDecorated), typeof(DecoratorC), typeof(DecoratorD))] FilterDecoratorSequenceChoiceAttribute Cancels an active Decoration Sequence selection. [FilterDecoratorSequenceChoice(typeof(IDecorated), typeof(DecoratedImplementation))] [FilterDecoratorSequenceChoice(typeof(IDecorated), typeof(IDecorated))] CompositeAbstractionAggregationAttribute Of each given abstraction, all its implementations are interpreted as composites. All abstractions are required to have a single generic type parameter. [CompositeAbstractionAggregation(typeof(IComposite<>))] FilterCompositeAbstractionAggregationAttribute Of each given abstraction, all its implementations are interpreted as composites. All abstractions are required to have a single generic type parameter. [FilterCompositeAbstractionAggregation(typeof(IComposite<>))] Recommendations Decorators and composites should be marked as such, otherwise DIE will interpret them as additional implementation types of their interface. The latter can be inconvenient, requiring more configuration (implementation choices or filtering). When marked, decorators and composites are excluded from regular use of implementations.","title":"Decorator/Composite Configurations"},{"location":"configuration/decorator-composite/#decoratorcomposite-configurations","text":"","title":"Decorator/Composite Configurations"},{"location":"configuration/decorator-composite/#purpose","text":"Since DIE doesn't just assume which implementation is a decorator or a composite, you've got to tell it by - you guessed it :) - configuration. When a decorated interface has more than one decorator, DIE doesn't assume the order in which the decorators should be applied. Therefore, there is an attribute that can be used to configure this as well.","title":"Purpose"},{"location":"configuration/decorator-composite/#attributes","text":"DecoratorAbstractionAggregationAttribute Of each given abstraction, all its implementations are interpreted as decorators. All abstractions are required to have a single generic type parameter. [DecoratorAbstractionAggregation(typeof(IDecorator<>))] FilterDecoratorAbstractionAggregationAttribute Of each given abstraction, all its implementations are stopped being interpreted as decorators. All abstractions are required to have a single generic type parameter. [FilterDecoratorAbstractionAggregation(typeof(IDecorator<>))] DecoratorSequenceChoiceAttribute Selects a sequence of decorators to apply to the decorated implementation. This attribute is mandatory for all decorated implementations that have multiple decorators. A sequence can be configured either for the decorator interface type or for the concrete implementation. The configuration for the interface will be applied to all of its implementations, but if present, the configurations for the concrete implementation will take precedence. First, pass the decorated type interface, then the interface again (for fallback) or decorated implementation type (for specific), and then a list of decorator implementation types. The decorator implementations will be applied in order, that is, the decorated implementation instance will be injected into the first decorator implementation instance, which will be injected into the second, and so on. You can also disable decoration by leaving the list of decorator types empty. [DecoratorSequenceChoice(typeof(IDecorated), typeof(DecoratedImplementation), typeof(DecoratorA), typeof(DecoratorB))] [DecoratorSequenceChoice(typeof(IDecorated), typeof(IDecorated), typeof(DecoratorC), typeof(DecoratorD))] FilterDecoratorSequenceChoiceAttribute Cancels an active Decoration Sequence selection. [FilterDecoratorSequenceChoice(typeof(IDecorated), typeof(DecoratedImplementation))] [FilterDecoratorSequenceChoice(typeof(IDecorated), typeof(IDecorated))] CompositeAbstractionAggregationAttribute Of each given abstraction, all its implementations are interpreted as composites. All abstractions are required to have a single generic type parameter. [CompositeAbstractionAggregation(typeof(IComposite<>))] FilterCompositeAbstractionAggregationAttribute Of each given abstraction, all its implementations are interpreted as composites. All abstractions are required to have a single generic type parameter. [FilterCompositeAbstractionAggregation(typeof(IComposite<>))]","title":"Attributes"},{"location":"configuration/decorator-composite/#recommendations","text":"Decorators and composites should be marked as such, otherwise DIE will interpret them as additional implementation types of their interface. The latter can be inconvenient, requiring more configuration (implementation choices or filtering). When marked, decorators and composites are excluded from regular use of implementations.","title":"Recommendations"},{"location":"configuration/disposal/","text":"Disposal Configurations Purpose DIE automatically manages disposables for you and disposes of them when the container or (temporary) scope is discarded. However, sometimes you want to handle the disposal yourself. In these cases you need to tell the container or scopes not to manage these specific implementations. The attributes come in three flavors, which can be distinguished by the following terms: SyncTransient ignores IDisposable implementations for disposal management. AsyncTransient ignores IAsyncDisposable implementations for disposal management. Transient ignores IDisposable & IAsyncDisposable implementations for disposal management. Attributes TransientAbstractionAggregationAttribute For any given abstraction, all of its implementations are completely ignored for disposal management. [TransientAbstractionAggregation(typeof(IWillCleanItUpMyself))] FilterTransientAbstractionAggregationAttribute For each given abstraction, all of its implementations are considered again for disposal management. [FilterTransientAbstractionAggregation(typeof(IWillCleanItUpMyselfAsync))] TransientImplementationAggregationAttribute Any given implementation is completely ignored for disposal management. [TransientImplementationAggregation(typeof(DisposeMeAsap))] FilterTransientImplementationAggregationAttribute Each given implementation will be considered again for disposal management. [FilterTransientImplementationAggregation(typeof(DisposeMeAsapAsync))] SyncTransientAbstractionAggregationAttribute For any given abstraction, all of its implementations are ignored for sync disposal management. [SyncTransientAbstractionAggregation(typeof(IWillCleanItUpMyself))] FilterSyncTransientAbstractionAggregationAttribute For each given abstraction, all of its implementations are considered again for sync disposal management. [FilterSyncTransientAbstractionAggregation(typeof(IWillCleanItUpMyself))] SyncTransientImplementationAggregationAttribute Any given implementation will be ignored for sync disposal management. [SyncTransientImplementationAggregation(typeof(DisposeMeAsap))] FilterSyncTransientImplementationAggregationAttribute Any given implementation will be considered again for sync disposal management. [FilterSyncTransientImplementationAggregation(typeof(DisposeMeAsap))] AsyncTransientAbstractionAggregationAttribute For any given abstraction, all of its implementations are ignored for async disposal management. [AsyncTransientAbstractionAggregation(typeof(IWillCleanItUpMyselfAsync))] FilterAsyncTransientAbstractionAggregationAttribute For each given abstraction, all of its implementations are considered again for async disposal management. [FilterAsyncTransientAbstractionAggregation(typeof(IWillCleanItUpMyselfAsync))] AsyncTransientImplementationAggregationAttribute Any given implementation is ignored for async disposal management. [AsyncTransientImplementationAggregation(typeof(DisposeMeAsapAsync))] FilterAsyncTransientImplementationAggregationAttribute Any given implementation is considered for async disposal management. [FilterAsyncTransientImplementationAggregation(typeof(DisposeMeAsapAsync))] Recommendations Use the Transient flavor when an implementation implements both disposal interfaces and you want to ignore both. Or if you want the implementation's disposal to be ignored regardless of future changes to its disposal interfaces. If an implementation implements both disposal interfaces, but you only want one of them to be ignored, use either the SyncTransient or AsyncTransient flavor. Pass IDisposable and IAsyncDisposable to the TransientAbstractionAggregationAttribute if you want to effectively disable disposal management for implementations.","title":"Disposal Configurations"},{"location":"configuration/disposal/#disposal-configurations","text":"","title":"Disposal Configurations"},{"location":"configuration/disposal/#purpose","text":"DIE automatically manages disposables for you and disposes of them when the container or (temporary) scope is discarded. However, sometimes you want to handle the disposal yourself. In these cases you need to tell the container or scopes not to manage these specific implementations. The attributes come in three flavors, which can be distinguished by the following terms: SyncTransient ignores IDisposable implementations for disposal management. AsyncTransient ignores IAsyncDisposable implementations for disposal management. Transient ignores IDisposable & IAsyncDisposable implementations for disposal management.","title":"Purpose"},{"location":"configuration/disposal/#attributes","text":"TransientAbstractionAggregationAttribute For any given abstraction, all of its implementations are completely ignored for disposal management. [TransientAbstractionAggregation(typeof(IWillCleanItUpMyself))] FilterTransientAbstractionAggregationAttribute For each given abstraction, all of its implementations are considered again for disposal management. [FilterTransientAbstractionAggregation(typeof(IWillCleanItUpMyselfAsync))] TransientImplementationAggregationAttribute Any given implementation is completely ignored for disposal management. [TransientImplementationAggregation(typeof(DisposeMeAsap))] FilterTransientImplementationAggregationAttribute Each given implementation will be considered again for disposal management. [FilterTransientImplementationAggregation(typeof(DisposeMeAsapAsync))] SyncTransientAbstractionAggregationAttribute For any given abstraction, all of its implementations are ignored for sync disposal management. [SyncTransientAbstractionAggregation(typeof(IWillCleanItUpMyself))] FilterSyncTransientAbstractionAggregationAttribute For each given abstraction, all of its implementations are considered again for sync disposal management. [FilterSyncTransientAbstractionAggregation(typeof(IWillCleanItUpMyself))] SyncTransientImplementationAggregationAttribute Any given implementation will be ignored for sync disposal management. [SyncTransientImplementationAggregation(typeof(DisposeMeAsap))] FilterSyncTransientImplementationAggregationAttribute Any given implementation will be considered again for sync disposal management. [FilterSyncTransientImplementationAggregation(typeof(DisposeMeAsap))] AsyncTransientAbstractionAggregationAttribute For any given abstraction, all of its implementations are ignored for async disposal management. [AsyncTransientAbstractionAggregation(typeof(IWillCleanItUpMyselfAsync))] FilterAsyncTransientAbstractionAggregationAttribute For each given abstraction, all of its implementations are considered again for async disposal management. [FilterAsyncTransientAbstractionAggregation(typeof(IWillCleanItUpMyselfAsync))] AsyncTransientImplementationAggregationAttribute Any given implementation is ignored for async disposal management. [AsyncTransientImplementationAggregation(typeof(DisposeMeAsapAsync))] FilterAsyncTransientImplementationAggregationAttribute Any given implementation is considered for async disposal management. [FilterAsyncTransientImplementationAggregation(typeof(DisposeMeAsapAsync))]","title":"Attributes"},{"location":"configuration/disposal/#recommendations","text":"Use the Transient flavor when an implementation implements both disposal interfaces and you want to ignore both. Or if you want the implementation's disposal to be ignored regardless of future changes to its disposal interfaces. If an implementation implements both disposal interfaces, but you only want one of them to be ignored, use either the SyncTransient or AsyncTransient flavor. Pass IDisposable and IAsyncDisposable to the TransientAbstractionAggregationAttribute if you want to effectively disable disposal management for implementations.","title":"Recommendations"},{"location":"configuration/generics/","text":"Decorator/Composite Configurations Purpose In general, it is possible for a generic parameter to be left open at resolution. If you configure generic parameter substitutes (for collections) and/or singular choices (for singular injections), then the implementation in which the configured generic parameter would otherwise remain open can still be resolved. Attributes GenericParameterSubstitutesChoiceAttribute Aggregates generic type substitutes for the given unbound generic implementation and the selected generic parameter. [GenericParameterSubstitutesChoice(typeof(Implementation<,>), \"T0\", typeof(int), typeof(string))] FilterGenericParameterSubstitutesChoiceAttribute Discards generic type substitutions for the given unbound generic implementation and the selected generic parameter. [FilterGenericParameterSubstitutesChoice(typeof(Implementation<,>), \"T0\")] GenericParameterChoiceAttribute Specifies the generic type choice for the given unbound generic implementation and the selected generic parameter. For collections, this choice is automatically added. [GenericParameterChoice(typeof(Implementation<,>), \"T0\", typeof(int))] FilterGenericParameterChoiceAttribute Discards the generic type choice for the given unbound generic implementation and the selected generic parameter. [FilterGenericParameterChoice(typeof(Implementation<,>), \"T0\")] Recommendations Be aware that if a generic implementation is resolved into a collection (for example, IReadOnlyList<\u2026> ) with multiple open generic type parameters, DIE will resolve closed versions of the implementation for all possible combinations of substitutes. For example, if an implementation has three open generic parameters, each of which has five substitutes configured, then 5 * 5 * 5 = 125 closed versions of the implementation will be resolved. The number of closed implementations can grow quickly, so it is recommended to be cautious. The singular choices (from GenericParameterChoice ) are automatically interpreted as additional substitutes for collections. So if you have a GenericParameterChoice and a GenericParameterSubstitutesChoice for the same implementation/type parameter combination, then it's not necessary to have the chosen type from the GenericParameterChoice in the GenericParameterSubstitutesChoice as well.","title":"Decorator/Composite Configurations"},{"location":"configuration/generics/#decoratorcomposite-configurations","text":"","title":"Decorator/Composite Configurations"},{"location":"configuration/generics/#purpose","text":"In general, it is possible for a generic parameter to be left open at resolution. If you configure generic parameter substitutes (for collections) and/or singular choices (for singular injections), then the implementation in which the configured generic parameter would otherwise remain open can still be resolved.","title":"Purpose"},{"location":"configuration/generics/#attributes","text":"GenericParameterSubstitutesChoiceAttribute Aggregates generic type substitutes for the given unbound generic implementation and the selected generic parameter. [GenericParameterSubstitutesChoice(typeof(Implementation<,>), \"T0\", typeof(int), typeof(string))] FilterGenericParameterSubstitutesChoiceAttribute Discards generic type substitutions for the given unbound generic implementation and the selected generic parameter. [FilterGenericParameterSubstitutesChoice(typeof(Implementation<,>), \"T0\")] GenericParameterChoiceAttribute Specifies the generic type choice for the given unbound generic implementation and the selected generic parameter. For collections, this choice is automatically added. [GenericParameterChoice(typeof(Implementation<,>), \"T0\", typeof(int))] FilterGenericParameterChoiceAttribute Discards the generic type choice for the given unbound generic implementation and the selected generic parameter. [FilterGenericParameterChoice(typeof(Implementation<,>), \"T0\")]","title":"Attributes"},{"location":"configuration/generics/#recommendations","text":"Be aware that if a generic implementation is resolved into a collection (for example, IReadOnlyList<\u2026> ) with multiple open generic type parameters, DIE will resolve closed versions of the implementation for all possible combinations of substitutes. For example, if an implementation has three open generic parameters, each of which has five substitutes configured, then 5 * 5 * 5 = 125 closed versions of the implementation will be resolved. The number of closed implementations can grow quickly, so it is recommended to be cautious. The singular choices (from GenericParameterChoice ) are automatically interpreted as additional substitutes for collections. So if you have a GenericParameterChoice and a GenericParameterSubstitutesChoice for the same implementation/type parameter combination, then it's not necessary to have the chosen type from the GenericParameterChoice in the GenericParameterSubstitutesChoice as well.","title":"Recommendations"},{"location":"configuration/implementations/","text":"Implementation Configurations Purpose Implementations must be collected in order to be considered by DIE. Otherwise, they won't be considered as substitutes for their interface, and injecting the type explicitly still won't compile. The container or scope needs to know which implementations to consider, so the purpose of implementation configuration is to tell them. Other configuration options include choosing constructors (if an implementation has multiple), properties for property injections, an implementation for an abstraction (if it has multiple implementations), and collections of implementations for collection injections of abstractions. Attributes AllImplementationAggregationAttribute Aggregates all implementations of the current assembly and all referenced assemblies. This includes .Net assemblies and assemblies from nuget packages. [assembly:AllImplementationsAggregation] FilterAllImplementationAggregationAttribute Filters all implementations. [FilterAllImplementationsAggregation] AssemblyImplementationsAggregationAttribute Aggregates all implementations of a given assembly. Assemblies are passed by referencing any type from the assembly, because assemblies themselves cannot be referenced in code. You may pass multiple types to this attribute. [AssemblyImplementationsAggregation(typeof(MrMeeseeks.DIE.TestNotInternalsVisibleToChild.AssemblyInfo))] FilterAssemblyImplementationsAggregationAttribute Filters all implementations of a given assembly. Assemblies are passed by any type from the assembly because assemblies themselves cannot be referenced in code. You may pass multiple types to this attribute. [FilterAssemblyImplementationsAggregation(typeof(MrMeeseeks.DIE.TestNotInternalsVisibleToChild.AssemblyInfo))] ImplementationAggregationAttribute Aggregates all given implementations. Types passed must be implementations. You may pass multiple types to this attribute. [ImplementationAggregation(typeof(DateTime), typeof(FileInfo))] FilterImplementationAggregationAttribute Filters all given implementations. Types passed must be implementations. You may pass multiple types to this attribute. [FilterImplementationAggregation(typeof(DateTime), typeof(FileInfo))] ConstructorChoiceAttribute Selects a constructor for the given implementation type to be used by DIE. If an implementation has multiple constructors that could potentially be used, choosing a constructor is mandatory for the implementation to be usable. Pass the implementation type first, then the types of the constructor parameters in the same order. To choose the parameterless constructor, just pass the only implementation type. [ConstructorChoice(typeof(Implementation), typeof(string), typeof(int))] FilterConstructorChoiceAttribute Discards the inherited constructor choice for the given implementation type. Just pass the implementation type. [FilterConstructorChoice(typeof(Implementation))] PropertyChoiceAttribute Selects the properties to be injected during instantiation. These properties must be mutable for the container (i.e. either public set/init or internal set/init within the same assembly or with appropriate InternalsVisibleTo usage). If no property choice is active, DIE will inject all accessible init properties by default. On the other hand, if a property choice is active, DIE will not inject any init properties that are not passed to the choice. Pass the implementation type first, followed by the names of the properties to be injected as strings. [PropertyChoice(typeof(Implementation), \"Logger\", \"Settings\")] FilterPropertyChoiceAttribute Discards the current property choice for the given implementation type. Just pass the implementation type. [FilterPropertyChoice(typeof(Implementation))] ImplementationChoiceAttribute For the given abstraction type, it chooses the given implementation type, even if multiple implementations are registered. Pass the abstraction type first and the implementation type second. [ImplementationChoice(typeof(IInterface), typeof(Implementation))] FilterImplementationChoiceAttribute Discards the current implementation choice for the given abstraction type. Pass only the abstraction type. [FilterImplementationChoice(typeof(IInterface))] ImplementationCollectionChoiceAttribute For the given abstraction type, it chooses the implementation types for collection injections. Pass the abstraction type first, then the implementation types. [ImplementationCollectionChoice(typeof(IInterface), typeof(ImplementationA), typeof(ImplementationB))] FilterImplementationCollectionChoiceAttribute Discards the inherited implementation collection choice for the given abstraction type. Pass only the abstraction type. [FilterImplementationCollectionChoice(typeof(IInterface))] Recommendations Use AllImplementationsAggregation at the assembly level, so that you can opt out with smaller filters starting at the container level. If you want to configure each type explicitly, use only `ImplementationAggregation'. Constructor choices are only mandatory if the implementation has multiple constructor candidates. If you know for sure that an implementation has only one usable constructor, you don't need to configure it. Constructor choice is especially important for implementations of assemblies that you don't have control over (such as .Net assemblies), because you can't make sure that these implementations have only one constructor. Because DIE takes full control of instantiation, init properties are injected by default. This doesn't apply to set properties. If you want to override this behavior, use property choices. If a property choice is active that doesn't contain the name of an init property, then that property will not be injected. If a property choice is active that contains the name of a set property, then the property will be injected. To completely disable property injection for an implementation, just pass the implementation type to the property choice.","title":"Implementation Configurations"},{"location":"configuration/implementations/#implementation-configurations","text":"","title":"Implementation Configurations"},{"location":"configuration/implementations/#purpose","text":"Implementations must be collected in order to be considered by DIE. Otherwise, they won't be considered as substitutes for their interface, and injecting the type explicitly still won't compile. The container or scope needs to know which implementations to consider, so the purpose of implementation configuration is to tell them. Other configuration options include choosing constructors (if an implementation has multiple), properties for property injections, an implementation for an abstraction (if it has multiple implementations), and collections of implementations for collection injections of abstractions.","title":"Purpose"},{"location":"configuration/implementations/#attributes","text":"AllImplementationAggregationAttribute Aggregates all implementations of the current assembly and all referenced assemblies. This includes .Net assemblies and assemblies from nuget packages. [assembly:AllImplementationsAggregation] FilterAllImplementationAggregationAttribute Filters all implementations. [FilterAllImplementationsAggregation] AssemblyImplementationsAggregationAttribute Aggregates all implementations of a given assembly. Assemblies are passed by referencing any type from the assembly, because assemblies themselves cannot be referenced in code. You may pass multiple types to this attribute. [AssemblyImplementationsAggregation(typeof(MrMeeseeks.DIE.TestNotInternalsVisibleToChild.AssemblyInfo))] FilterAssemblyImplementationsAggregationAttribute Filters all implementations of a given assembly. Assemblies are passed by any type from the assembly because assemblies themselves cannot be referenced in code. You may pass multiple types to this attribute. [FilterAssemblyImplementationsAggregation(typeof(MrMeeseeks.DIE.TestNotInternalsVisibleToChild.AssemblyInfo))] ImplementationAggregationAttribute Aggregates all given implementations. Types passed must be implementations. You may pass multiple types to this attribute. [ImplementationAggregation(typeof(DateTime), typeof(FileInfo))] FilterImplementationAggregationAttribute Filters all given implementations. Types passed must be implementations. You may pass multiple types to this attribute. [FilterImplementationAggregation(typeof(DateTime), typeof(FileInfo))] ConstructorChoiceAttribute Selects a constructor for the given implementation type to be used by DIE. If an implementation has multiple constructors that could potentially be used, choosing a constructor is mandatory for the implementation to be usable. Pass the implementation type first, then the types of the constructor parameters in the same order. To choose the parameterless constructor, just pass the only implementation type. [ConstructorChoice(typeof(Implementation), typeof(string), typeof(int))] FilterConstructorChoiceAttribute Discards the inherited constructor choice for the given implementation type. Just pass the implementation type. [FilterConstructorChoice(typeof(Implementation))] PropertyChoiceAttribute Selects the properties to be injected during instantiation. These properties must be mutable for the container (i.e. either public set/init or internal set/init within the same assembly or with appropriate InternalsVisibleTo usage). If no property choice is active, DIE will inject all accessible init properties by default. On the other hand, if a property choice is active, DIE will not inject any init properties that are not passed to the choice. Pass the implementation type first, followed by the names of the properties to be injected as strings. [PropertyChoice(typeof(Implementation), \"Logger\", \"Settings\")] FilterPropertyChoiceAttribute Discards the current property choice for the given implementation type. Just pass the implementation type. [FilterPropertyChoice(typeof(Implementation))] ImplementationChoiceAttribute For the given abstraction type, it chooses the given implementation type, even if multiple implementations are registered. Pass the abstraction type first and the implementation type second. [ImplementationChoice(typeof(IInterface), typeof(Implementation))] FilterImplementationChoiceAttribute Discards the current implementation choice for the given abstraction type. Pass only the abstraction type. [FilterImplementationChoice(typeof(IInterface))] ImplementationCollectionChoiceAttribute For the given abstraction type, it chooses the implementation types for collection injections. Pass the abstraction type first, then the implementation types. [ImplementationCollectionChoice(typeof(IInterface), typeof(ImplementationA), typeof(ImplementationB))] FilterImplementationCollectionChoiceAttribute Discards the inherited implementation collection choice for the given abstraction type. Pass only the abstraction type. [FilterImplementationCollectionChoice(typeof(IInterface))]","title":"Attributes"},{"location":"configuration/implementations/#recommendations","text":"Use AllImplementationsAggregation at the assembly level, so that you can opt out with smaller filters starting at the container level. If you want to configure each type explicitly, use only `ImplementationAggregation'. Constructor choices are only mandatory if the implementation has multiple constructor candidates. If you know for sure that an implementation has only one usable constructor, you don't need to configure it. Constructor choice is especially important for implementations of assemblies that you don't have control over (such as .Net assemblies), because you can't make sure that these implementations have only one constructor. Because DIE takes full control of instantiation, init properties are injected by default. This doesn't apply to set properties. If you want to override this behavior, use property choices. If a property choice is active that doesn't contain the name of an init property, then that property will not be injected. If a property choice is active that contains the name of a set property, then the property will be injected. To completely disable property injection for an implementation, just pass the implementation type to the property choice.","title":"Recommendations"},{"location":"configuration/miscellaneous/","text":"Miscellaneous Configurations Purpose These are the attributes that don't fit into the other categories. Their purpose is to define initializers and containers/create functions. Attributes InitializedInstancesAttribute Can be used on container and scope classes. Instances of given implementation types will be created automatically in time of initialization of the relevant container or scope. [InitializedInstances(typeof(OperatingSystemObserver), typeof(DatabaseInitialization))] InitializerAttribute Lets you specify which types have an initialization method that should be used during instantiation. Pass the type that owns the initialization method first, then the name of the method. There is one constraint on the method: it must return either nothing (void), a Task , or a ValueTask . [Initializer(typeof(IAsyncInitializer), \"InitializeAsync\")] FilterInitializerAttribute Discards an active initializer method definition. Pass the type that owns the initializer method. [FilterInitializer(typeof(IAsyncInitializer))] CreateFunctionAttribute Defines a create function that DIE should create in the container. This attribute defines which classes should be interpreted as containers. Pass first the type to be returned by the create function and then the name to be given to the create function. [CreateFunction(typeof(IAppRoot), \"Create\")]","title":"Miscellaneous Configurations"},{"location":"configuration/miscellaneous/#miscellaneous-configurations","text":"","title":"Miscellaneous Configurations"},{"location":"configuration/miscellaneous/#purpose","text":"These are the attributes that don't fit into the other categories. Their purpose is to define initializers and containers/create functions.","title":"Purpose"},{"location":"configuration/miscellaneous/#attributes","text":"InitializedInstancesAttribute Can be used on container and scope classes. Instances of given implementation types will be created automatically in time of initialization of the relevant container or scope. [InitializedInstances(typeof(OperatingSystemObserver), typeof(DatabaseInitialization))] InitializerAttribute Lets you specify which types have an initialization method that should be used during instantiation. Pass the type that owns the initialization method first, then the name of the method. There is one constraint on the method: it must return either nothing (void), a Task , or a ValueTask . [Initializer(typeof(IAsyncInitializer), \"InitializeAsync\")] FilterInitializerAttribute Discards an active initializer method definition. Pass the type that owns the initializer method. [FilterInitializer(typeof(IAsyncInitializer))] CreateFunctionAttribute Defines a create function that DIE should create in the container. This attribute defines which classes should be interpreted as containers. Pass first the type to be returned by the create function and then the name to be given to the create function. [CreateFunction(typeof(IAppRoot), \"Create\")]","title":"Attributes"},{"location":"configuration/scoping/","text":"Scoping Configurations Purpose There are two purposes for scoping configurations: Scoped Instances Scoped instances aren't instantiated per dependency injection, but at most once for a given scope. DIE cannot simply assume which of the implementations should be treated as scoped instances and for which type of scope (the container, the transient scope, or the scope). So if you want to share instances of certain implementations, you must tell DIE which implementation in which scope. Scope Roots are implementations that mark the beginning of a scope. When DIE needs to instantiate a scope root, it creates a new scope and resolves the scope root as it's root instance. That is, the scope root is the first instance of its scope. DIE doesn't expect any implementations to be scope roots, so it needs to be configured. Attributes ContainerInstanceAbstractionAggregationAttribute For each given abstraction, all of its implementations are marked as scoped instances for the container. [ContainerInstanceAbstractionAggregation(typeof(IAllTheSingles))] FilterContainerInstanceAbstractionAggregationAttribute For each given abstraction, all of its implementations are discarded as scoped instances for the container. [FilterContainerInstanceAbstractionAggregation(typeof(INotSingleAnymore))] ContainerInstanceImplementationAggregationAttribute Given implementations are marked as scoped instances for the container. [ContainerInstanceImplementationAggregation(typeof(Single))] FilterContainerInstanceImplementationAggregationAttribute Given implementations are discarded as scoped instances for the container. [FilterContainerInstanceImplementationAggregation(typeof(NotSingleAnymore))] TransientScopeInstanceAbstractionAggregationAttribute For each given abstraction, all of its implementations are marked as scoped instances for transient scopes. [TransientScopeInstanceAbstractionAggregation(typeof(IAllTheSingles))] FilterTransientScopeInstanceAbstractionAggregationAttribute For any given abstraction, all of its implementations are discarded as scoped instances for transient scopes. [FilterTransientScopeInstanceAbstractionAggregation(typeof(INotSingleAnymore))] TransientScopeInstanceImplementationAggregationAttribute Given implementations are marked as scoped instances for transient scopes. [TransientScopeInstanceImplementationAggregation(typeof(Single))] FilterTransientScopeInstanceImplementationAggregationAttribute Given implementations are discarded as scoped instances for transient scopes. [FilterTransientScopeInstanceImplementationAggregation(typeof(NotSingleAnymore))] ScopeInstanceAbstractionAggregationAttribute For each given abstraction, all of its implementations are marked as scoped instances for scopes. [ScopeInstanceAbstractionAggregation(typeof(IAllTheSingles))] FilterScopeInstanceAbstractionAggregationAttribute Of any given abstraction, all of its implementations are discarded as scoped instances for scopes. [FilterScopeInstanceAbstractionAggregation(typeof(INotSingleAnymore))] ScopeInstanceImplementationAggregationAttribute Given implementations are marked as scoped instances for scopes. [ScopeInstanceImplementationAggregation(typeof(Single))] FilterScopeInstanceImplementationAggregationAttribute Given implementations are discarded as scoped instances for scopes. [FilterScopeInstanceImplementationAggregation(typeof(NotSingleAnymore))] TransientScopeRootAbstractionAggregationAttribute For each given abstraction, all of its implementations are marked as scope roots for transient scopes. [TransientScopeRootAbstractionAggregation(typeof(IBeginningOfSomething))] FilterTransientScopeRootAbstractionAggregationAttribute For any given abstraction, all of its implementations are discarded as scope roots for transient scopes. [FilterTransientScopeRootAbstractionAggregation(typeof(IOrdinaryDependency))] TransientScopeRootImplementationAggregationAttribute Given implementations are marked as scope roots for transient scopes. [TransientScopeRootImplementationAggregation(typeof(Ceo))] FilterTransientScopeRootImplementationAggregationAttribute Given implementations are discarded as scope roots for transient scopes. [FilterTransientScopeRootImplementationAggregation(typeof(Trainee))] ScopeRootAbstractionAggregationAttribute For each given abstraction, all of its implementations are marked as scope roots for scopes. [ScopeRootAbstractionAggregation(typeof(IBeginningOfSomething))] FilterScopeRootAbstractionAggregationAttribute For any given abstraction, all of its implementations are discarded as scope roots for scopes. [FilterScopeRootAbstractionAggregation(typeof(IOrdinaryDependency))] ScopeRootImplementationAggregationAttribute Given implementations are marked as scope roots for scopes. [ScopeRootImplementationAggregation(typeof(Ceo))] FilterScopeRootImplementationAggregationAttribute Given implementations are discarded as scope roots for scopes. [FilterScopeRootImplementationAggregation(typeof(Trainee))] Recommendations Use transient scoped instances as needed. This is because the complexity of transient scoped instances is greater than that of container instances and scoped instances. Therefore, if an instance can be used throughout the container, you should consider marking it as a container instance. And if an instance can be limited to being shared in a scope, then consider marking it as a scope instance.","title":"Scoping Configurations"},{"location":"configuration/scoping/#scoping-configurations","text":"","title":"Scoping Configurations"},{"location":"configuration/scoping/#purpose","text":"There are two purposes for scoping configurations: Scoped Instances Scoped instances aren't instantiated per dependency injection, but at most once for a given scope. DIE cannot simply assume which of the implementations should be treated as scoped instances and for which type of scope (the container, the transient scope, or the scope). So if you want to share instances of certain implementations, you must tell DIE which implementation in which scope. Scope Roots are implementations that mark the beginning of a scope. When DIE needs to instantiate a scope root, it creates a new scope and resolves the scope root as it's root instance. That is, the scope root is the first instance of its scope. DIE doesn't expect any implementations to be scope roots, so it needs to be configured.","title":"Purpose"},{"location":"configuration/scoping/#attributes","text":"ContainerInstanceAbstractionAggregationAttribute For each given abstraction, all of its implementations are marked as scoped instances for the container. [ContainerInstanceAbstractionAggregation(typeof(IAllTheSingles))] FilterContainerInstanceAbstractionAggregationAttribute For each given abstraction, all of its implementations are discarded as scoped instances for the container. [FilterContainerInstanceAbstractionAggregation(typeof(INotSingleAnymore))] ContainerInstanceImplementationAggregationAttribute Given implementations are marked as scoped instances for the container. [ContainerInstanceImplementationAggregation(typeof(Single))] FilterContainerInstanceImplementationAggregationAttribute Given implementations are discarded as scoped instances for the container. [FilterContainerInstanceImplementationAggregation(typeof(NotSingleAnymore))] TransientScopeInstanceAbstractionAggregationAttribute For each given abstraction, all of its implementations are marked as scoped instances for transient scopes. [TransientScopeInstanceAbstractionAggregation(typeof(IAllTheSingles))] FilterTransientScopeInstanceAbstractionAggregationAttribute For any given abstraction, all of its implementations are discarded as scoped instances for transient scopes. [FilterTransientScopeInstanceAbstractionAggregation(typeof(INotSingleAnymore))] TransientScopeInstanceImplementationAggregationAttribute Given implementations are marked as scoped instances for transient scopes. [TransientScopeInstanceImplementationAggregation(typeof(Single))] FilterTransientScopeInstanceImplementationAggregationAttribute Given implementations are discarded as scoped instances for transient scopes. [FilterTransientScopeInstanceImplementationAggregation(typeof(NotSingleAnymore))] ScopeInstanceAbstractionAggregationAttribute For each given abstraction, all of its implementations are marked as scoped instances for scopes. [ScopeInstanceAbstractionAggregation(typeof(IAllTheSingles))] FilterScopeInstanceAbstractionAggregationAttribute Of any given abstraction, all of its implementations are discarded as scoped instances for scopes. [FilterScopeInstanceAbstractionAggregation(typeof(INotSingleAnymore))] ScopeInstanceImplementationAggregationAttribute Given implementations are marked as scoped instances for scopes. [ScopeInstanceImplementationAggregation(typeof(Single))] FilterScopeInstanceImplementationAggregationAttribute Given implementations are discarded as scoped instances for scopes. [FilterScopeInstanceImplementationAggregation(typeof(NotSingleAnymore))] TransientScopeRootAbstractionAggregationAttribute For each given abstraction, all of its implementations are marked as scope roots for transient scopes. [TransientScopeRootAbstractionAggregation(typeof(IBeginningOfSomething))] FilterTransientScopeRootAbstractionAggregationAttribute For any given abstraction, all of its implementations are discarded as scope roots for transient scopes. [FilterTransientScopeRootAbstractionAggregation(typeof(IOrdinaryDependency))] TransientScopeRootImplementationAggregationAttribute Given implementations are marked as scope roots for transient scopes. [TransientScopeRootImplementationAggregation(typeof(Ceo))] FilterTransientScopeRootImplementationAggregationAttribute Given implementations are discarded as scope roots for transient scopes. [FilterTransientScopeRootImplementationAggregation(typeof(Trainee))] ScopeRootAbstractionAggregationAttribute For each given abstraction, all of its implementations are marked as scope roots for scopes. [ScopeRootAbstractionAggregation(typeof(IBeginningOfSomething))] FilterScopeRootAbstractionAggregationAttribute For any given abstraction, all of its implementations are discarded as scope roots for scopes. [FilterScopeRootAbstractionAggregation(typeof(IOrdinaryDependency))] ScopeRootImplementationAggregationAttribute Given implementations are marked as scope roots for scopes. [ScopeRootImplementationAggregation(typeof(Ceo))] FilterScopeRootImplementationAggregationAttribute Given implementations are discarded as scope roots for scopes. [FilterScopeRootImplementationAggregation(typeof(Trainee))]","title":"Attributes"},{"location":"configuration/scoping/#recommendations","text":"Use transient scoped instances as needed. This is because the complexity of transient scoped instances is greater than that of container instances and scoped instances. Therefore, if an instance can be used throughout the container, you should consider marking it as a container instance. And if an instance can be limited to being shared in a scope, then consider marking it as a scope instance.","title":"Recommendations"}]}